#!/usr/bin/env bash
# Turnix docs metadata pre-commit hook (hardened, docs/ only, auto docId+file, repo-local Python)
#
# Scope:
# - Only staged files under docs/** with .md/.txt/.json5
#
# Requires:
# - Git
# - Repo-local embeddable Python at ./python-embedded/python.exe
#
# Guarantees for each targeted staged file (newest spec: doc-meta footer):
# - Document MUST end with exactly one doc-meta block:
#     --- doc-meta ---
#     docId: <canonical document identifier>
#     file: <canonical repository path>
#     rev: <revision count>
#     git: <short commit id>
#     ----------------
# - docId is derived from filename: "<dirs>/<docId>_<normalized>.<EXT>"
#   - docId pattern: one or more [A-Z], then "-", then one or more [A-Z0-9]
# - file is the repo-relative path as staged (forward slashes)
# - rev is computed as (commit-count touching file) + 1 when the file is staged with changes
# - git is the last commit hash that touched the file before this commit (0000000 for new files)
#
# Safety / anti-footgun:
# - Refuses to run if a file has partially staged changes (staged + unstaged), because the hook edits and re-stages
#   the whole file and would destroy partial staging.
# - Refuses ambiguous/malformed doc-meta blocks (missing/duplicate markers, content after footer, etc.)
# - Refuses if required tools are missing
# - Enforces doc-meta structure and ordering; overwrites the doc-meta block content to match spec

set -euo pipefail
IFS=$'\n\t'

die() {
  echo "ERROR: $*" >&2
  exit 1
}

needCmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

needCmd git

repoRoot="$(git rev-parse --show-toplevel 2>/dev/null)" || die "Not a git repository"
cd "$repoRoot"

PY_EXE="$repoRoot/python-embedded/python.exe"
if [ ! -f "$PY_EXE" ]; then
  die "Missing repo-local Python: $PY_EXE
Run setup.ps1 (from repo root) to install the embeddable runtime, then retry the commit."
fi

# Basic sanity check that it runs
if ! "$PY_EXE" -c "import sys; assert sys.version_info >= (3, 12)" >/dev/null 2>&1; then
  die "Repo-local Python exists but failed to run or is not Python 3.12+: $PY_EXE"
fi

isDocsFileWanted() {
  local f="$1"
  case "$f" in
    docs/*.md|docs/*.txt|docs/*.json5|docs/*/*.md|docs/*/*.txt|docs/*/*.json5|docs/*/*/*.md|docs/*/*/*.txt|docs/*/*/*.json5|docs/*/*/*/*.md|docs/*/*/*/*.txt|docs/*/*/*/*.json5|docs/*/*/*/*/*.md|docs/*/*/*/*/*.txt|docs/*/*/*/*/*.json5)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# Extract docId from repo-relative path:
# - path must start with "docs/"
# - filename part is after last "/"
# - filename format: "<docId>_<normalized text>.<EXT>"
# - docId is before first "_"
# - docId regex: ^[A-Z]+-[A-Z0-9]+$
extractDocIdFromPathOrDie() {
  local path="$1"

  [[ -n "$path" ]] || die "Path cannot be empty"
  [[ "$path" == docs/* ]] || die "Path must be under docs/: '$path'"

  local base="${path##*/}"
  [[ -n "$base" ]] || die "Filename cannot be empty: '$path'"

  # Must not be ".onlyextension" (no leading dot, must have at least one non-dot char before first dot)
  [[ "$base" != .* ]] || die "Filename must not start with '.': '$path'"

  # Must contain underscore (docId separator)
  [[ "$base" == *_* ]] || die "Filename must contain '_' after docId: '$path'"

  # Must contain at least one dot for extension
  [[ "$base" == *.* ]] || die "Filename must contain an extension (a '.'): '$path'"

  # First character must be [A-Z]
  [[ "${base:0:1}" =~ [A-Z] ]] || die "Filename must start with [A-Z]: '$path'"

  # Must contain '-' (per docId pattern)
  [[ "$base" == *-* ]] || die "Filename must contain '-' in docId: '$path'"

  local docId="${base%%_*}"
  [[ -n "$docId" ]] || die "docId extracted from filename is empty: '$path'"

  # Validate docId pattern: one or more [A-Z], '-', then one or more [A-Z0-9]
  if ! [[ "$docId" =~ ^[A-Z]+-[A-Z0-9]+$ ]]; then
    die "Invalid docId '$docId' extracted from '$path'.
Expected pattern: one or more [A-Z], then '-', then one or more [A-Z0-9]."
  fi

  printf '%s' "$docId"
}

# Read staged files under docs/ (NUL-delimited to handle spaces)
mapfile -d '' stagedFiles < <(git diff --cached --name-only -z --diff-filter=ACMR -- docs/)

if [ "${#stagedFiles[@]}" -eq 0 ]; then
  exit 0
fi

targets=()
for f in "${stagedFiles[@]}"; do
  if isDocsFileWanted "$f"; then
    targets+=("$f")
  fi
done

if [ "${#targets[@]}" -eq 0 ]; then
  exit 0
fi

# Guard: refuse partial staging for any target file (staged + unstaged)
for f in "${targets[@]}"; do
  [ -f "$f" ] || die "Staged path not found in working tree: $f"

  # If no staged changes, skip checks.
  if git diff --cached --quiet -- "$f"; then
    continue
  fi

  # If unstaged changes also exist, refuse.
  if ! git diff --quiet -- "$f"; then
    die "Partial staging detected for '$f'.
This hook edits and re-stages the whole file (would destroy partial staging).
Fix: stage the whole file (git add '$f') or stash/restore unstaged parts, then commit."
  fi
done

for f in "${targets[@]}"; do
  # Only update if the file has staged changes.
  if git diff --cached --quiet -- "$f"; then
    continue
  fi

  # Validate path + derive docId from filename
  expectedDocId="$(extractDocIdFromPathOrDie "$f")"

  # file is the repo-relative path (forward slashes) exactly as staged
  expectedFile="$f"

  # Last hash touching the file BEFORE this commit (short). If none (new file), use 0000000.
  lastHash="$(git log -n 1 --follow --pretty=format:%h -- "$f" 2>/dev/null || true)"
  if [ -z "$lastHash" ]; then
    lastHash="0000000"
  fi

  # rev base = number of commits touching the file so far (before this commit). New file => 0.
  revBase="$(git log --follow --pretty=format:%H -- "$f" 2>/dev/null | wc -l | tr -d ' ')"
  newRev=$((revBase + 1))

  "$PY_EXE" - "$f" "$expectedDocId" "$expectedFile" "$newRev" "$lastHash" <<'PY'
import sys

path = sys.argv[1]
expected_doc_id = sys.argv[2]
expected_file = sys.argv[3]
new_rev = int(sys.argv[4])
new_hash = sys.argv[5]

start_marker = "--- doc-meta ---"
end_marker = "----------------"

with open(path, "r", encoding="utf-8", newline="") as f:
  text = f.read()

# Preserve newline style where possible
newline = "\n"
if "\r\n" in text and "\n" in text:
  newline = "\r\n"

lines = text.replace("\r\n", "\n").split("\n")

# Find exactly one start marker
starts = [i for i, line in enumerate(lines) if line == start_marker]
if len(starts) != 1:
  raise SystemExit(
    f"ERROR: {path}: expected exactly one '{start_marker}' line, found {len(starts)}"
  )
s = starts[0]

# Find end marker after start
try:
  e = next(i for i in range(s + 1, len(lines)) if lines[i] == end_marker)
except StopIteration:
  raise SystemExit(f"ERROR: {path}: missing end marker '{end_marker}' after doc-meta start")

# Spec requires doc-meta at end of document (footer). Allow only trailing empty lines after end marker.
tail = lines[e + 1 :]
if any(line.strip() != "" for line in tail):
  raise SystemExit(
    f"ERROR: {path}: doc-meta block must be at the end of the document; found content after '{end_marker}'"
  )

# Build a canonical spec-compliant block (overwrite whatever was there).
# Exact required order:
# docId, file, rev, git
block = [
  f"docId: {expected_doc_id}",
  f"file: {expected_file}",
  f"rev: {new_rev}",
  f"git: {new_hash}",
]

# Enforce line length rule:
# - Only the value of the "file:" field MAY exceed 79 characters.
# - No other doc-meta line may exceed 79 characters.
def check_len(line: str, is_file: bool) -> None:
  if is_file:
    # file line can exceed 79, allowed by spec
    return
  if len(line) > 79:
    raise SystemExit(f"ERROR: {path}: doc-meta line exceeds 79 chars: '{line}'")

check_len(block[0], is_file=False)  # docId
check_len(block[1], is_file=True)   # file
check_len(block[2], is_file=False)  # rev
check_len(block[3], is_file=False)  # git

# Replace the existing block content (whatever it was) with the canonical block.
new_lines = lines[: s + 1] + block + [end_marker]

# Preserve a single trailing newline if the original file had one.
# (split("\n") drops the final empty item only if there was no trailing newline)
had_trailing_newline = text.endswith("\n") or text.endswith("\r\n")
new_text = newline.join(new_lines)
if had_trailing_newline:
  new_text += newline

with open(path, "w", encoding="utf-8", newline="") as f:
  f.write(new_text)
PY

  git add -- "$f"
done

exit 0
