**Turnix Project Blueprint (Updated)**

---

**Project Name:** Turnix\
**Core Purpose:** Modular AI-driven narrative and simulation engine with real-time pipeline extensibility, built for both experimentation and RPG-style storytelling.

---

## üåç Core Philosophy

Turnix is designed to be:

- **Extensible**: Modders and developers can hook into every part of the AI pipeline.
- **Deterministic**: Hook and pipeline execution is fully predictable.
- **Composable**: Internal systems such as memory, prompts, and world state can be re-ordered and reused.
- **View-aware**: Supports UI layout as a composition of views within a single client.
- **Template-driven**: Prompt generation is modular and model-aware, with compatibility testing and fallback support.

---

## ‚öôÔ∏è Architecture Overview

### 1. **Frontend (JS/HTML or Electron)**

- Each tab, window, or device is a **view**, identified by a `viewId`, all linked to a single `clientId` (the user/game instance).
- Each view runs its own JS runtime: `rpc.js`, `modloader.js`, `frontendBus`, and hook loader.
- Mods register hooks per view programmatically (not via manifest).
- Mods may also request creation of new views via backend (`requestView`).
- The frontend runtime loads only the mods and hooks relevant to its own `viewId`.
- Frontend WebSocket authentication uses per-view signed tokens generated by backend.

### 2. **Backend (Python)**

- FastAPI + WebSocket server
- Clients (users) can have multiple views (tabs/windows/devices)
- Mods are isolated per view and run hooks deterministically:
  - Sorted by `mod_id`
  - Then by `view_id` ("main" is always first)
  - Then by registration order (view creation time)
- Shared memory is available per mod, view-agnostic but deterministic
- Backend owns all memory, logging, model API, and pipeline scheduling
- **Authentication**: Signed tokens (e.g. HMAC) issued by backend for view WebSocket connections

### 3. **Mod System**

- Mods register hooks **programmatically** via runtime lifecycle methods:
  - `init()`: general init (non-view specific)
  - `activate(viewId)`: register hooks for a view
  - `deactivate(viewId)`: optional cleanup
  - `teardown()`: full mod unload
  - `pipelineCreated(pipeline)`: optional callback when new pipeline is instantiated
- Mod manifest describes only **metadata**, not hook declarations
- Mods can request new views from backend (`requestView(...)`) and hook into them

---

## ‚öñÔ∏è Pipeline Model

Stages:

- `PreInput`
- `PostInput`
- `PreQueryBuild`
- `PostQueryBuild`
- `PreQuerySend`
- `PostQueryReply`
- `PreStoreHistory`
- `PostStoreHistory`

Each stage is processed in order. Each hook within a stage is executed in this order:

1. By `mod_id`
2. By `view_id` ("main" first)
3. By registration order

Hooks are **not allowed to affect order** or trigger reruns.

---

## üß¨ Mod Views and Hook Execution

- The "main" view is always present. Mods start in main.
- Mods may choose not to register hooks in main, but instead request a secondary view.
- Hook execution is always scoped per view.
- Mods that register for the same stage on multiple views will have separate handlers per view.
- Mods share backend memory, but execution is isolated.
- Cross-view mod coordination is done via **shared memory**, not message passing.

---

## üìÇ Shared Mod Memory

- Each mod has access to its own shared memory space on the backend.
- Memory is read/write.
- No mod or view can trigger reruns based on memory changes.
- Execution order is deterministic; mods should not assume whether they are first or second.
- Memory is used to cache results, coordinate work, or share common data between views.

---

## üîó WebSocket and View Routing

- Each view maintains its own WebSocket connection to the backend.
- Backend manages all views under a single client (game/user instance).
- Mods cannot send arbitrary WebSocket messages.
- Backend provides routing helpers (`sendToView`, `broadcastToViews`), sandboxed inside `modContext`.
- Mods must register hooks per view explicitly if they want to operate across views.
- Views register themselves on connect with `viewId`, `clientId`, and optional tags.
- New `viewId`s are generated on the backend to enforce resource limits and control view creation.
- Each WebSocket request includes: `requestId`, `viewId`, `clientId`, `ownerId`, `type`, `timestamp`, and optionally `handler`, `message`, or `extra`

---

## üß™ Subpipelines & Template System

- Pipelines are named by template: e.g. `LLM.main`, `LLM.hidden`, `image.generation`, `tts.speak`
- Main LLM pipeline is shared by all mods; others may be spawned dynamically
- Mods can spawn new pipelines via `createPipeline(template, config)` and then `run()`
- Mods may register hooks to known templates
- `pipelineCreated(pipeline)` is called for all pipelines
- Mods that spawn pipelines may `resolveUntilStage(stageName)` and receive results in metadata

---

## üóïÔ∏è Prompt Templates & Compatibility

- Each model can have its own optimized prompt template.
- Prompts are generated through a registry (`PromptTemplateRegistry`) depending on:
  - Model ID or capability profile
  - Task type (e.g. scene.reasoning, item.generation)
  - Desired output format (structured steps, JSONL, plain text)
- Pipeline chooses the best available template or retries simpler fallback

### Prompt Testing Framework

- Models are tested for compatibility with various prompt templates
- Results are stored and scored (success rate, token efficiency, parse reliability)
- Invalid results trigger fallback, simpler formatting, or per-step regeneration
- Validator functions per template check for correctness (e.g., presence of 3 `<step:N>` blocks)

---

## üìÖ Manifest Structure (Minimal)

```yaml
name: debug-tools
version: 1.0.0
author: you
license: MIT
description: Custom debug UI
```

No hooks or views are declared in manifest. All behavior is registered in code.

---

## ‚úÖ Summary

Turnix is a deterministic, pipeline-based, modular AI runtime with full mod/view separation. It avoids the pitfalls of declarative-only mod systems and allows modders to flexibly load, unload, or reassign functionality across dynamic views. The backend is authoritative on memory, scheduling, view creation, and model access. The frontend is a runtime shell that can render mod output, register hooks, and request layout changes.

This design supports:

- Rich, modular UIs
- Companion devices
- View-specific rendering
- Safe per-mod memory sharing
- Controlled expansion to multiplayer or streaming observers
- Dynamic prompt formatting and model compatibility fallback
- Subpipeline spawning with callback/sync behavior
- Per-pipeline introspection via `pipelineCreated()`

It avoids:

- Cross-mod side effects
- Pipeline instability
- Manifest-driven rigidity

