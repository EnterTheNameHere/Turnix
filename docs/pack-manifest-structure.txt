TURNIX PACK & ASSET RESOLUTION SPEC (DRAFT)

============================================================
0. OVERVIEW
============================================================

This spec defines:

- How packs are discovered and represented (PackMeta).
- How references to packs are written by creators (PackRefString / PackRequest).
- How semantic versioning (SemVer*) is used for packs.
- How assets are declared and resolved via the "assets" field.
- How visibility and export of nested packs work at resolution time.
- Constraints and invariants (no lazy discovery during resolution).

Authority note:
    Manifest shape, defaults, and field semantics are defined in:

        docs/pack-manifest-structure.txt

    That document is the canonical reference for manifest fields, including:
        - kind, id, author, version
        - visibility
        - exportNestedPacks
        - importFromParent
        - assets, exports, dependency hints

    This document focuses on resolution and runtime handling and must not
    contradict the manifest authority file.


============================================================
1. TERMINOLOGY
============================================================

Pack kinds (kind):
    - "appPack"
    - "viewPack"
    - "mod"
    - "contentPack"
    - "savePack"

Roots:
    - first-party
    - third-party
    - custom
    - saves

Pack directory:
    A directory that contains a manifest file (e.g. manifest.json5).
    That directory is the root of a pack tree (for that pack).


============================================================
2. SEMVER TERMINOLOGY
============================================================

SemVerPackVersion:
    - A semantic version string declared in a pack manifest.
    - Examples: "1.0.0", "2.5.3", "0.1.0-alpha.1".

SemVerPackRequirement:
    - A semantic version range requested by a dependency or by a PackRefString.
    - Examples: "^2.5.0", ">=1.2 <2.0", "2.5.3", "*".
    - If omitted, it is treated as: "no constraint", i.e. "any version".

SemVerMatchResult:
    - Result of matching multiple SemVerPackVersion values against one
      SemVerPackRequirement.
    - Contains:
        kind: "none", "single", or "multiple"
        matches: list of PackMeta (or (version, PackMeta) pairs)

SemVerResolver:
    - Component responsible only for matching versions.
    - Signature (conceptual):
        match(
            candidates: list[(SemVerPackVersion, PackMeta)],
            requirement: SemVerPackRequirement | None
        ) -> SemVerMatchResult


============================================================
3. IDENTITY TERMINOLOGY
============================================================

There are three levels related to "id":

3.1 PackLocalId (manifest-level id)
    - The value of "id" in the manifest.
    - Local to the pack tree; used as one segment in a hierarchical id.
    - Constraints:
        - Must NOT contain '@'.
        - Must NOT contain a semver string.
        - Must NOT contain '.' (dot); dots are reserved for hierarchy construction.
    - Examples:
        "ui"
        "trace"
        "trace-view"

3.2 packTreeId (hierarchical id)
    - Hierarchical dotted name built from PackLocalIds along the parent chain.
    - Constructed during discovery / PackMeta building.
    - Rules:
        - Root pack: packTreeId = PackLocalId
        - Child:     packTreeId = parent.packTreeId + "." + localId
    - Examples (contentPack "ui", mod "trace", mod "trace-view"):
        "ui"                      (root)
        "ui.trace"                (child of ui)
        "ui.trace.trace-view"     (child of trace)

3.3 Fully qualified reference string (PackRefString)
    - What creators write in manifests to refer to other packs:
        "<author?>@<packTreeId>[@<SemVerPackRequirement>]"
    - Examples:
        "ui"                               (no author, no version requirement)
        "Anthony@avatars"                  (author + id)
        "Turnix@ui.trace.trace-list@2.5.3" (author + id + exact version)
        "Turnix@main-menu.ui@^3"           (author + id + version range)


============================================================
4. PACK REPRESENTATION (PACKMETA)
============================================================

PackMeta is the immutable catalog entry for a single pack, created during
discovery (scan / rescan). It is not modified during resolution.

Fields (conceptual):

    PackMeta:
        localId: PackLocalId
        packTreeId: str               # hierarchical id ("ui.trace.trace-view")
        declaredAuthor: str | None    # as written in manifest
        declaredSemVerPackVersion: SemVerPackVersion | None  # as in manifest

        effectiveAuthor: str          # after inheritance from parent
        effectiveSemVerPackVersion: SemVerPackVersion  # after inheritance

        isVersionAgnostic: bool       # optional; true if pack declares itself
                                      # "serves all versions"

        kind: str                     # "appPack", "mod", etc.
        rootPath: Path                # directory of this pack
        manifestPath: Path            # path to manifest.json5
        layer: "first-party" | "third-party" | "custom" | "saves"
        parent: PackMeta | None       # parent in pack tree

        declaredVisibility: "public" | "private" | None
        effectiveVisibility: "public" | "private"
            # final visibility after applying inheritance rules

        exportNestedMode: "all" | "none" | "list"
            # normalized form of exportNestedPacks:
            #   true  -> "all"
            #   false -> "none"
            #   [ids] -> "list"
        exportNestedList: set[PackLocalId]
            # ids listed when exportNestedMode == "list"

        importFromParent: bool        # whether dependencies are inherited
                                      # from parent (after defaults applied)

        exportsCapabilities: list[str]
            # from exports.capabilities, if any; purely informational for the
            # capability system

        recommendedPacks: list[PackRequest]   # optional compatibility hints
        supportedPacks: list[PackRequest]     # optional compatibility hints
        unsupportedPacks: list[PackRequest]   # optional compatibility hints

        assets: dict[str, AssetMeta]  # logicalName -> AssetMeta

        runtimeEntries: dict[str, list[Path]]
            # e.g. { "python": ["service.py"], "javascript": ["ui.js"] }

    AssetMeta:
        logicalName: str   # e.g. "Sandy.png", "config.json", "mesh:hero"
        relPath: Path      # path relative to pack root, e.g. "assets/Sandy.png"
        kind: str          # "image", "config", "text", "binary", etc.

Effective author + version:
    - effectiveAuthor:
        - If manifest declares "author": use it.
        - Else, if parent exists: inherit parent's effectiveAuthor.
        - Else: may be "unknown" or a process-default value. Collisions on
          (effectiveAuthor, packTreeId, kind, version) should be treated as
          errors.

    - effectiveSemVerPackVersion:
        - If manifest declares "version": use it.
        - Else, if parent exists: inherit parent's effectiveSemVerPackVersion.
        - Else: default to a value defined by the engine (for example, "0.0.0")
          or require explicit version in root packs by policy.

Effective visibility:
    - declaredVisibility:
        - Directly from manifest.visibility or None.

    - effectiveVisibility rules (aligned with manifest spec):
        - If pack has no parent (root of a tree):
            - If manifest.visibility is set: use it.
            - If omitted: default to "public".
        - If pack has a parent:
            - If manifest.visibility is set: use it.
            - If omitted: inherit parent's effectiveVisibility.

Exporting nested packs (global visibility):
    - exportNestedPacks comes from manifest and is normalized into:
        - exportNestedMode: "all" | "none" | "list"
        - exportNestedList: set[PackLocalId] (only relevant for "list")

    - Suggested default policy for exportNestedPacks in discovery:
        - If manifest.exportNestedPacks is explicitly:
            true      -> exportNestedMode = "all"
            false     -> exportNestedMode = "none"
            array     -> exportNestedMode = "list", exportNestedList = that array
        - If manifest.exportNestedPacks is omitted:
            - For kind == "contentPack":
                default to "all"
            - For kind in {"appPack", "viewPack", "mod", "savePack"}:
                default to "none"

    - Whether a child pack is globally resolvable by other, unrelated packs
      depends on:
        - The child's effectiveVisibility (must be "public"), AND
        - The ancestor chain:
            - At least one ancestor must effectively export nested packs in a
              way that covers this child:
                - ancestor.exportNestedMode == "all", or
                - ancestor.exportNestedMode == "list" and the child id appears
                  in that ancestor's exportNestedList.

Nested export flag (conceptual):
    - For convenience, PackMetaRegistry may precompute a flag such as
      isGloballyExported for each PackMeta, meaning:
        - This pack is visible to external PackRequests:
            - effectiveVisibility == "public", AND
            - Exported by at least one ancestor according to the rules above.

isVersionAgnostic:
    - Optional semantic flag meaning "I conceptually serve all versions".
    - Used by SemVerResolver to decide priority when multiple candidates exist.
    - Implementation detail; may be omitted initially.


============================================================
5. PACK REQUESTS (PACKREFSTRING, PACKREQUEST)
============================================================

PackRefString:
    - Raw string written in manifest to depend on a pack.
    - Grammar:
        [<author>"@"]<packTreeId>["@"<SemVerPackRequirement>]

Examples:
    "avatars"
    "Anthony@avatars"
    "Turnix@ui.trace.trace-list@2.5.3"
    "Turnix@main-menu.ui@^3"

PackRequest (parsed form):

    PackRequest:
        author: str | None                  # from prefix before first "@"
        packTreeId: str                     # hierarchical id portion
        semverRequirement: SemVerPackRequirement | None  # suffix after last "@"
        kind: str | None                    # optional filter: "mod", "contentPack", etc.

Examples:

    "Anthony@avatars"
      -> PackRequest(
             author="Anthony",
             packTreeId="avatars",
             semverRequirement=None,
             kind=None)

    "Turnix@ui.trace.trace-list@2.5.3"
      -> PackRequest(
             author="Turnix",
             packTreeId="ui.trace.trace-list",
             semverRequirement="2.5.3",
             kind=None)


============================================================
6. DISCOVERY PHASE (SCAN → PACKMETA REGISTRY)
============================================================

There are two phases:

    Phase 1: Discovery (scan / rescan).
    Phase 2: Resolution (respond to PackRequests).

Invariants:
    - Discovery builds / updates the complete PackMeta registry.
    - Resolution MUST NOT trigger new filesystem scanning or manifest discovery.
    - Resolution uses only the current PackMeta registry snapshot.

Discovery steps (high level):

1. For each root (first-party, third-party, custom, saves):
    - Walk directories as defined by the root system spec.
    - When a manifest file is found in a directory, treat that directory as a
      pack root.
    - Create PackMeta for that root pack.
    - Recursively search inside that directory for child pack directories with
      their own manifest files, honoring root boundary rules.

2. For each pack discovered:
    - Read manifest (at least: kind, id, author, version, visibility,
      exportNestedPacks, importFromParent, assets).
    - Determine parent PackMeta (if any).
    - Compute:

        localId = manifest.id

        packTreeId:
            if parent is None:
                packTreeId = localId
            else:
                packTreeId = parent.packTreeId + "." + localId

        declaredAuthor =
            author.name (if author is object) or author (if string) or None

        effectiveAuthor:
            if declaredAuthor is not None:
                use declaredAuthor
            elif parent exists:
                inherit parent.effectiveAuthor
            else:
                use engine-defined default (for example, "unknown")

        declaredSemVerPackVersion =
            manifest.version or None

        effectiveSemVerPackVersion:
            if declaredSemVerPackVersion is not None:
                use it
            elif parent exists:
                inherit parent.effectiveSemVerPackVersion
            else:
                use engine-defined default (for example, "0.0.0")

        declaredVisibility =
            manifest.visibility or None

        effectiveVisibility (see manifest spec rules):
            if parent is None:
                if manifest.visibility is set:
                    use that value
                else:
                    "public"
            else:
                if manifest.visibility is set:
                    use that value
                else:
                    parent.effectiveVisibility

        exportNestedPacks normalization:
            v = manifest.exportNestedPacks (may be bool, array, or missing)
            if v is true:
                exportNestedMode = "all"
                exportNestedList = empty set
            elif v is false:
                exportNestedMode = "none"
                exportNestedList = empty set
            elif v is an array:
                exportNestedMode = "list"
                exportNestedList = set(v)
            else (missing):
                if kind == "contentPack":
                    exportNestedMode = "all"
                    exportNestedList = empty set
                else:
                    exportNestedMode = "none"
                    exportNestedList = empty set

        importFromParent:
            if manifest.importFromParent is explicitly true or false:
                use that value
            else:
                default:
                    if kind == "viewPack":
                        False
                    else:
                        True

        exportsCapabilities:
            - From manifest.exports.capabilities if present and is a list,
              otherwise [].
            - No special handling for pack exports here; pack visibility /
              export is determined by effectiveVisibility and the
              exportNestedPacks logic.

        recommendedPacks, supportedPacks, unsupportedPacks:
            - Normalize to lists of PackRequest by parsing the "id" field or
              the raw string, ignoring "reason" at this level.

    - Process "assets" (see section 7) and fill PackMeta.assets.
    - Optionally prepare runtimeEntries from the kind-specific blocks in the
      manifest (for example, mod.runtimes).

3. Determine global export for nested packs:
    - When building the registry, for each PackMeta compute a flag
      isGloballyExported (conceptual):

        - Start with effectiveVisibility:
            if effectiveVisibility != "public":
                isGloballyExported = False
            else:
                walk ancestor chain from root to this pack:
                    if any ancestor has:
                        exportNestedMode == "all"
                        OR exportNestedMode == "list" and this localId is in
                           that ancestor's exportNestedList:
                        then this pack is a candidate for global registry.
                        break
                if no such ancestor is found:
                    isGloballyExported = False
                else:
                    isGloballyExported = True

    - The registry must ensure that only packs with isGloballyExported == True
      are considered for external resolution, unless a caller explicitly asks
      for "internal" resolution within a specific parent tree.

4. Register all PackMeta objects into a PackMetaRegistry.
   The registry must support queries by:
    - packTreeId
    - (effectiveAuthor, packTreeId, kind)
    - (effectiveAuthor, packTreeId, kind, version)
    - plus filters such as isGloballyExported where appropriate.

No lazy discovery rule:
    - Once discovery finishes (or a rescan completes), every pack that exists
      under roots must appear in the PackMetaRegistry.
    - Resolution must not trigger filesystem traversal or manifest probing.


============================================================
7. ASSET DECLARATION ("assets" FIELD)
============================================================

Goal:
    - Allow creators to expose directories of assets without listing each file.
    - Auto-include only files with safe extensions.
    - Allow explicit inclusion of non-safe or unusual file types.

Manifest key: "assets"

Type:
    "assets": [
        "<dir-or-file-string>" | {
            "dir": "<directory>",
            "files": [ "<relative-file-or-subpath>", ... ],
            "safeAuto": bool (optional, default true)
        },
        ...
    ]

String form:
    "assets": ["assets", "images/portraits"]

    For each string entry:
        - Interpret as a directory path relative to pack root.
        - At discovery, walk the directory recursively.
        - Auto-include all files with "safe" extensions (see below) into
          PackMeta.assets.

Object form:
    "assets": [
        {
            "dir": "raw-avatars",
            "files": ["avatar.dat", "special/mesh.bin"]
        }
    ]

    Semantics:
        - dir: directory base path relative to pack root.
        - files: list of paths (relative to dir) that are explicitly allowed,
                 even if extension is not safe.
        - safeAuto (optional, default true):
            - If true: include safe files under "dir" automatically, plus files
              in "files".
            - If false: include ONLY the listed "files" from that dir.

Safe extensions:
    Engine-defined list, for example:
        Images:  .png, .jpg, .jpeg, .webp, .gif
        Text:    .txt, .json, .json5, .yml, .yaml, .toml, .ini, .csv, .tsv
        (optional) Sounds: .wav, .ogg, etc.

    These are auto-included for string entries and for object entries with
    safeAuto: true.

Unknown/unsafe extensions:
    - NOT auto-included.
    - Only included if explicitly listed in an object entry's "files" array.

PackMeta.assets construction (simplified):

    For each "assets" entry:
        - If entry is a string (dirPath):
            - Recursively scan dirPath.
            - For each file:
                - If extension in safe list:
                    logicalName = filename (or relative path, depending on
                    design).
                    assets[logicalName] = AssetMeta(...)

        - If entry is an object:
            - If safeAuto is true or unspecified:
                - same as above: include safe files under dir.
            - For each "file" in files:
                - include that file regardless of extension.
                - logicalName can be the filename or a customized alias if
                  needed.

Assets namespace resolution:
    - By default, logicalName is just the filename ("Sandy.png").
    - If multiple assets with same logicalName exist from different packs, the
      pack context (which contentPack or appPack a mod depends on) disambiguates.


============================================================
8. RESOLUTION PHASE (PACKRESOLVER)
============================================================

PackResolver:
    - Resolves PackRequest -> ResolvedPack using PackMetaRegistry.

ResolvedPack (conceptual):

    ResolvedPack:
        meta: PackMeta          # the PackMeta that won
        sourceLayer: str        # where the pack came from: "saves",
                               # "first-party", etc.
        replaced: list[PackMeta]# packs shadowed or replaced (optional)

        # convenience mirrors:
        author: str
        packTreeId: str
        semverPackVersion: SemVerPackVersion
        kind: str
        rootPath: Path
        manifestPath: Path
        runtimeEntries: dict[str, list[Path]]
        assets: dict[str, AssetMeta]

Visibility and export considerations:
    - By default, PackResolver should only consider PackMeta entries where:
        - meta.isGloballyExported == True
      unless a call explicitly requests an internal resolution within a known
      parent tree.

Resolution steps (for a normal external PackRequest):

    def resolvePack(request: PackRequest, registry: PackMetaRegistry) -> ResolvedPack:
        # 1. Filter by packTreeId, author, kind, and global export
        candidates = [
            m for m in registry.all()
            if m.packTreeId == request.packTreeId
            and (request.author is None or m.effectiveAuthor == request.author)
            and (request.kind is None or m.kind == request.kind)
            and getattr(m, "isGloballyExported", True)
        ]

        # 2. SemVer filtering
        version_pairs = [(m.effectiveSemVerPackVersion, m) for m in candidates]
        match = SemVerResolver.match(version_pairs, request.semverRequirement)

        # 3. Interpret SemVerMatchResult:
        #    - none -> ResolutionError("No matching version")
        #    - multiple -> ResolutionError("Ambiguous version")
        #    - single -> build ResolvedPack from that PackMeta

        return resolvedPack

Internal resolution variants:
    - Some engine paths may want to resolve child packs that are internal to a
      given parent tree (for example, a viewPack resolving its own nested
      private mods). In that case the resolver can:
        - Accept an additional context parameter (such as parent PackMeta), and
        - Restrict lookup to that tree, ignoring isGloballyExported, or
        - Use direct parent → child relationships without going through the
          global index.

    These internal modes are outside the scope of this spec, but they must not
    violate the no-lazy-discovery rule: they still operate on existing PackMeta
    objects only.


============================================================
9. ASSET RESOLUTION API (CONCEPTUAL)
============================================================

AssetRequest (conceptual):

    AssetRequest:
        pack: PackRequest or ResolvedPack  # usually a ResolvedPack for content
        assetName: str                     # e.g. "Sandy.png"

Runtime (mod) side (example):

    // JS (conceptual)
    const sandy = await ctx.assets.get("Sandy.png");

    // Given that this mod declares:
    //   packs: ["Anthony@avatars"]
    // and "avatars" is resolved to some ResolvedPack "avatarsPack",

AssetResolver:

    def getAsset(resolvedPack: ResolvedPack, assetName: str) -> AssetMeta:
        return resolvedPack.meta.assets.get(assetName)
        # raise if not found; may support fallbacks later.


============================================================
10. INVARIANTS AND ERROR CASES
============================================================

Discovery / rescan:
    - Must build a complete PackMeta registry for all packs under roots.
    - Must detect collisions where:
        - Two packs share the same
          (effectiveAuthor, packTreeId, kind, effectiveSemVerPackVersion)
          in the same precedence layer, and no explicit override mechanism
          is in place.
    - Must apply manifest semantics correctly:
        - visibility
        - exportNestedPacks
        - importFromParent
        - assets
    - May reject manifests with invalid or conflicting id/author/version fields.

Visibility and export invariants:
    - A pack is considered globally resolvable by default only if:
        - effectiveVisibility == "public", AND
        - It is exported according to exportNestedPacks rules in its parent
          chain (isGloballyExported == True in the registry).
    - Packs with effectiveVisibility == "private" must not be returned by the
      public resolution path unless resolution is explicitly scoped to the
      parent tree that owns them.

Resolution:
    - Must not touch filesystem or read manifests.
    - Must fail clearly if:
        - No PackMeta matches PackRequest.packTreeId / author / kind under
          the chosen visibility/export rules.
        - SemVerResolver returns "none" or "multiple" for a given request.
    - Must treat PackRequests with missing author or missing
      semverRequirement as wildcards, not as errors.

Assets:
    - Only files that appear in PackMeta.assets may be served via asset APIs.
    - Unknown extensions are not served unless specifically configured in
      the "assets" list.
    - Asset resolution must not trigger filesystem traversal; it uses only
      PackMeta.assets.

End of spec (draft).
