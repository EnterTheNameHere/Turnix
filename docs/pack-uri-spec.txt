Turnix Pack URI and Resolution Specification
============================================

Authority note: pack-manifest-structure.txt is the canonical reference for
manifest fields and their semantics. Identity, semantic versioning, and
PackDescriptor/PackResolver behaviour continue to be covered in
pack-and-asset-resolution.txt. This document only describes the URI surface and
save-metadata examples. When in doubt, defer to the authoritative specs, with
pack-manifest-structure.txt and pack-and-asset-resolution.txt taking
precedence over this document where any ambiguity arises.

This document defines the addressing scheme for packs and resources in Turnix.
It is written as if for an automatic code generator: every term is precise and
every component is described with clear responsibilities and inputs/outputs.

The focus is on what must exist (interfaces, behaviours, invariants), not how it
is implemented.


------------------------------------------------------------
1. Design goals
------------------------------------------------------------

1. Stable identities for packs
   Every pack (application pack, view pack, mod, content pack, save pack) has a
   stable identifier that can be referenced in manifests and during execution.

2. Uniform URI scheme
   The same grammar is used to reference files and packs of different kinds,
   with a scheme://author@id prefix indicating how to interpret the reference.

3. Deterministic resolution
   Given the same configuration, discovery set, and save metadata, the resolver
   must deterministically select the same concrete pack and version unless the
   user explicitly chooses to upgrade.

4. Support for embedded and global packs
   Packs may embed other packs (for example, an application pack containing
   local user interface mods), and there are also globally installed packs.
   Resolution must consider both scopes in a predictable way.

5. Upgradeable but backwards-safe saves
   Saves remember both:
   - the original semantic request (for example, listbox:^1.0.0) and
   - the exact resolved pack (for example, mod://Jan@listbox:1.1.0),
   allowing controlled upgrades with rollback.


------------------------------------------------------------
2. Core concepts and glossary
------------------------------------------------------------

These terms are used consistently throughout the system.


2.1 Pack kinds
--------------

A pack is a directory with a manifest and additional files. Pack kinds include:

- appPack – an application bundle that can create and own AppInstances and saves.
- viewPack – a bundle that provides one or more debugging or auxiliary views.
- mod – a reusable functionality unit attached to an application or view.
- contentPack – optional: data-only or mostly-data packs.
- savePack – pack kind used for per-save resources, typically stored under
    the saves/ root as described in the root system spec. A savePack has its
    own manifest and participates in discovery and resolution like other packs.


2.2 Manifest fields (common)
----------------------------

Manifest fields mirror the PackDescriptor inputs described in pack-manifest-structure.txt:

{
  "kind": "appPack" | "viewPack" | "mod" | "contentPack" | "savePack",
  "author": "Turnix",           // declaredAuthor; may be inherited by children
  "id": "main-menu",            // PackLocalId; must not contain '@', '.' or semver
  "name": "Main Menu",          // optional user-facing name (defaults to id)
  "version": "1.0.0",           // declaredSemVerPackVersion
  "visibility": "public",       // optional; see pack-manifest-structure.txt for defaults
  "importFromParent": false     // optional; semantics and defaults are defined
                                // in pack-manifest-structure.txt
}

Important notes:

- id is the stable, local slug that feeds into the hierarchical packTreeId built
  during discovery.
- name is purely for user interfaces and may contain spaces, capitalization,
  etc.; omit to fall back to id.
- kind drives how the pack is interpreted and where it is stored on disk.
- Visibility and dependency inheritance (importFromParent) follow the defaults
  described in pack-manifest-structure.txt.
- The effective author and version may be inherited from a parent pack as
  defined in the PackDescriptor rules.


2.3 Source kinds
----------------

Each pack additionally belongs to a source kind, derived from its author and
installation location:

- first-party – maintained by Turnix itself (usually author == "Turnix").
- third-party – installed from external sources, organized by author.
- custom – user-created or local development packs.
- saves – per-save generated data (for example, generated application packs or
  embedded mods inside saves).

Source kind is used for filesystem layout and for decisions about mutability and
overwrite rules.


2.4 Pack identity and selectors
-------------------------------

Pack identity: (effectiveAuthor, packTreeId)

- packTreeId is the dotted hierarchy (ui.trace.trace-view) derived from manifest
  id values; see pack-and-asset-resolution.txt for construction rules.

Pack reference string (PackRefString / PackRequest): a textual reference that
may be partial and requires resolution:

  <author?>@<packTreeId>[@<SemVerPackRequirement>]

where author and version requirement are optional wildcards.

Resolved pack id (ResolvedPackId): a canonical, fully-resolved reference that
includes an exact version and scheme:

  <scheme>://<authorId>@<packTreeId>:<SemVerPackVersion>

Examples:

- appPack://Turnix@main-menu:1.2.0
- viewPack://Turnix@trace-monitor:1.0.0
- mod://Enter@ui.trace.listbox:1.0.0
- mod://Jan@ui.trace.listbox:1.1.0

Request vs canonical forms:

- **Request selectors** may use a semantic version **requirement**:
    <author?>@<packTreeId>[@<SemVerPackRequirement>]
  for example:
    "Turnix@ui.trace.listbox@^1.0.0"

- **Canonical resolved ids** always use an **exact version** with a colon:
    <scheme>://<authorId>@<packTreeId>:<SemVerPackVersion>
  for example:
    "mod://Turnix@ui.trace.listbox:1.1.0"

Compatibility note: Older references to packId in this document should be
interpreted as the packTreeId root segment. Where dotted packTreeId values
appear, map each segment to a directory level when constructing filesystem
paths.

2.5 Resource URIs
-----------------

A resource URI references a file inside a pack or directory:

  <scheme>://<authorId?>@<packTreeIdOrDir>[@<SemVerPackRequirement>][/inner/path...]

Examples:

- file://Turnix@config/defaults/global.json5
- appPack://Turnix@main-menu/saves/manifest.json5
- mod://Turnix@toast/toast.js
- viewPack://Turnix@trace-monitor/trace-monitor.js

Where:

- scheme identifies the resolution strategy:
  - file – direct mapping to first-party configuration and similar files.
  - appPack – application packs.
  - viewPack – view packs.
  - mod – mods.
  - Additional schemes can be added later (contentPack, savePack, etc.).
- inner/path... is an internal path relative to the resolved pack root (if
  applicable).


------------------------------------------------------------
3. URI grammar and mapping rules
------------------------------------------------------------


3.1 General grammar
-------------------

The general grammar for resource URIs is:

  <scheme>://<authorId?>@<packTreeIdOrDir>[@<SemVerPackRequirement>][/inner/path...]

Where:

- scheme is a lowercase identifier (no spaces; no "://" inside).
- authorId is taken from the manifest author field and is optional in requests
  but mandatory in canonical URIs.
- packTreeIdOrDir is either:
  - the dotted packTreeId of a pack (for pack-ish schemes), or
  - a top-level directory (config, etc.) for file://.
- SemVerPackRequirement follows the semantics from pack-and-asset-resolution.txt.
- inner/path is optional. When omitted, the root of the pack is referenced.


3.2 Scheme-specific mapping rules
---------------------------------


3.2.1 file:// scheme
---------------------

Used for first-party configuration and similar plain files.

Example:

  file://Turnix@config/defaults/global.json5

Mapping:

  <root>/first-party/config/defaults/global.json5

Resolution rules for file://:

1. authorId == "Turnix":
   - Base directory: <root>/first-party/.
   - packIdOrDir is used as the top-level directory.
2. For other authors, optional extension (if needed in the future):
   - <root>/third-party/config/<authorId>/... or a similar pattern.

No semantic pack resolution is performed; file:// is primarily a convenience for
first-party configuration files and similar resources.


3.2.2 appPack://, viewPack://, mod://
-------------------------------------

All pack-based schemes follow the same mapping pattern.

Pack-based schemes do not map to fixed directory structures.
They resolve through the PackDescriptorRegistry:

1. Resolve <author>@<packTreeId>@<versionRequirement> into a PackDescriptor.
2. Use PackDescriptor.packRoot for filesystem access.
3. Append inner/path if present.

All directory structure rules come from roots-and-discovery.txt,
not from URI scheme names.


3.2.3 Source kind and mutability
--------------------------------

Source kind controls mutability rules:

- first-party directories under <root>/first-party/ are treated as read-only
  during execution.
- third-party directories under <root>/third-party/ are also treated as
  read-only except for controlled updates (installer or package manager).
- custom directories under <root>/custom/ are considered authored content and
  are treated as read-only during execution (they are edited by users or tools
  in an authoring workflow, not by the running process).
- save directories under <root>/saves/ are writable for AppInstance-specific
  state, and userdata directories under <root>/userdata/ are writable for
  global configuration and state (see the root system spec).

Any generator or execution-time code attempting to write into a read-only pack
directory must raise a controlled exception, which may be caught and handled by
higher-level logic (for example, migrating writes into saves/ or userdata/).


------------------------------------------------------------
4. Filesystem layout
------------------------------------------------------------

The following layout is the reference target state.


4.1 First-party layout
----------------------

This section is non-authoritative.
Turnix no longer organizes packs by kind-specific directories.
Discovery follows roots-and-discovery.txt:

  <root>/first-party/<anyPackRoot>/manifest.json5
  <root>/third-party/<anyPackRoot>/manifest.json5
  <root>/custom/<anyPackRoot>/manifest.json5

Nested packs are discovered by scanning within packRoot recursively.

Concrete example from the main-menu and 100floors scenario:

  <root>/first-party/appPacks/100floors/manifest.json5
  <root>/first-party/appPacks/100floors/generator.js
  <root>/first-party/appPacks/100floors/src/100floors.js

  <root>/first-party/appPacks/main-menu/manifest.json5
  <root>/first-party/appPacks/main-menu/generator.js
  <root>/first-party/appPacks/main-menu/mods/main-menu-ui/manifest.json5
  <root>/first-party/appPacks/main-menu/mods/main-menu-ui/main-menu-ui.js
  <root>/first-party/appPacks/main-menu/mods/main-menu-ui/template/css/style.something
  <root>/first-party/appPacks/main-menu/mods/main-menu-ui/template/html.something

  <root>/first-party/viewPacks/trace-monitor/manifest.json5
  <root>/first-party/viewPacks/trace-monitor/trace-monitor.js

  <root>/first-party/mods/toast/manifest.json5
  <root>/first-party/mods/toast/toast.js

  <root>/first-party/mods/ui/manifest.json5
  <root>/first-party/mods/ui/button.js
  <root>/first-party/mods/ui/textarea.js
  <root>/first-party/mods/ui/messageslist.js
  <root>/first-party/mods/ui/dialog.js
  <root>/first-party/mods/ui/menu.js


4.2 Third-party layout
----------------------

Third-party packs are organized by author and version:

Third-party packs follow the same discovery rules as first-party:

  <root>/third-party/<anyPackRoot>/manifest.json5

Author/version directories may exist but are not part of the authoritative
resolution strategy. Discovery uses manifest metadata, not path structure.

Example:

  <root>/third-party/mods/Enter/listbox/1.0.0/manifest.json5
  <root>/third-party/mods/Enter/listbox/1.0.0/listbox.js

  <root>/third-party/mods/Jan/listbox/1.1.0/manifest.json5
  <root>/third-party/mods/Jan/listbox/1.1.0/listbox.js

This layout allows multiple versions of a pack to coexist.


4.3 Saves and userdata
----------------------

While not fully specified here, the expected pattern for saves is:

  <root>/saves/<appPackId>/<appInstanceId>/...

Each save directory is expected to contain a savePack manifest that records:

- original pack selectors,
- resolved pack ids,
- appInstance identifiers,
- other metadata.

User-global configuration and data can live under:

  <root>/userdata/...


------------------------------------------------------------
5. Resolution pipeline
------------------------------------------------------------

The resolution pipeline is organized into several conceptual components that a
code generator or hand-written implementation can treat as separate modules.


5.1 PackRequestParser
---------------------

Input: string of the form

  <author?>@<packTreeId>[@<SemVerPackRequirement>]

Output: structured selector object compatible with PackRequest:

  type PackRequest = {
    author?: string;           // optional wildcard
    packTreeId: string;        // dotted hierarchy built from manifest ids
    semverRequirement?: string; // semver range per pack-and-asset-resolution
    kind?: string | null;      // optional filter: "mod", "contentPack", etc.
  }

Responsibilities:

- Parse a selector string into fields.
- Enforce syntax rules (characters allowed in author and packTreeId).
- Reject invalid or ambiguous strings with clear error messages.


5.2 PackDescriptorRegistry (conceptual view)
----------------------

Input: list of root directories (first-party, third-party, custom, saves)  
Output: in-memory index of available packs.

The index stores entries as PackDescriptor objects.
PackDescriptorRegistry provides indexed lookup by:
  - packTreeId
  - (author, packTreeId)
  - (author, packTreeId, version)

Responsibilities:

- Walk the directories under <root>/first-party, <root>/third-party,
  <root>/custom, and <root>/saves.
- Detect manifests (manifest.json5, manifest.json) and parse kind, author, id,
  version, etc., building the dotted packTreeId during traversal.
- Build a lookup structure keyed by (kind, author, packTreeId) and full
  (kind, author, packTreeId, exactVersion).

(Discovery must obey the constraints and invariants described in
pack-and-asset-resolution.txt and the root-system spec, including visibility
and globalVisibility rules.)


5.3 VersionChooser
------------------

Input:

- versionSpec (may be undefined),
- list of candidate exact versions for the given pack.

Output: one chosen exactVersion.

Responsibilities:

- If versionSpec is undefined:
  - Use a default policy (usually highest available version).
- If versionSpec is defined:
  - Filter candidates that satisfy the constraint (^1.0.0, >=1.0.0 <2.0.0, etc.).
  - Choose the highest matching version.
- If no candidate matches:
  - Return an error; the higher level will decide whether to abort or provide a
    fallback.


5.4 ScopeResolver (local vs global)
-----------------------------------

Packs can be embedded inside other packs (for example, UI mods in an application
pack). The ScopeResolver describes a recommended local-then-global lookup strategy
that builds on top of the PackDescriptorRegistry rules from
pack-and-asset-resolution.txt.

For a requesting pack P wanting a dependency with selector S:

Search order:

1. Local scope of P
   For example, for appPack://Turnix@main-menu, search for nested packs
   under P's packRoot (as discovered according to roots-and-discovery and
   pack-and-asset-resolution), such as:

     <packRoot>/mods/<localId>/manifest.json5

   The exact directory names (e.g. "mods") are not prescribed by this
   specification; they are part of the pack's own layout. If a nested pack is
   found, treat it as a normal PackDescriptor with its own manifest-defined
   id, author, and kind.

   Local scope may see **private** children (visibility=="private") inside the
   same pack tree. Visibility and exportNestedPacks do not restrict a parent
   from resolving its own nested private packs.

2. Global scope  
   If not found locally, use the PackDescriptorRegistry to find global
   candidates among first-party, third-party, and custom packs.

   Only descriptors whose **globalVisibility == "public"** (as defined by
   pack-and-asset-resolution.txt and pack-manifest-structure.txt) may be
   considered for global resolution. Private packs (visibility=="private") or
   children that are not exported by their parent via exportNestedPacks remain
   internal and must not appear as global candidates.

The ScopeResolver returns a set of candidate PackDescriptor objects to pass
into VersionChooser.


5.5 PackResolver
----------------

Input:

- scheme (determines kind)
- PackRequest (author may be missing)
- requesting context (for example, requesting pack identity for local scope)

Output: ResolvedPackId and the chosen PackDescriptor (or a ResolvedPack
        wrapper that contains PackDescriptor plus layer/source metadata).

Responsibilities:

1. Ensure author is known. If missing:
   - In local scope, use the author of the requesting pack.
   - In global scope, if multiple authors exist for the same packTreeId, this is
     an error unless disambiguated by configuration or user choice.

2. Use ScopeResolver to gather candidate packs by (kind, author, packTreeId).

3. Use VersionChooser to pick an exact version.

4. Return a canonical ResolvedPackId:

      <scheme>://<author>@<packTreeId>:<exactVersion>

    along with the corresponding PackDescriptor (or ResolvedPack), which
    contains filesystem paths and layer/source information.


5.6 ResourceUriResolver
-----------------------

Input: resource URI string  
Output: filesystem path to a file or directory

Responsibilities:

1. Parse the URI into:
   - scheme
   - authorId
   - packIdOrDir
   - versionSpec
   - innerPath

2. If scheme == "file":
   - Map directly to <root>/first-party/<packIdOrDir>/<innerPath> when
     authorId == "Turnix".
   - Optionally support extension to other authors in third-party or custom.

3. If scheme is a pack scheme (appPack, viewPack, mod, contentPack, savePack):
   - Derive pack kind from scheme.
   - Treat packIdOrDir as packId (or packTreeId, depending on convention).
   - Construct a PackRequest from authorId, packId, versionSpec
     (SemVerPackRequirement). Canonical resolved forms use an exact version in
      the ResolvedPackId (<scheme>://author@packTreeId:version).
   - Use PackResolver to get PackIndexEntry.
   - Return PackIndexEntry.rootPath combined with innerPath (if any).


------------------------------------------------------------
6. Save manifests and upgrade behaviour
------------------------------------------------------------

Saves must store both the semantic intent and the concrete resolution of
dependencies, consistent with pack-and-asset-resolution.txt.


6.1 Save metadata structure
---------------------------

Example metadata snippet inside a save manifest:

{
  "appPack": "appPack://Turnix@100floors:1.0.0",
  "requestedPacks": {
    "ui": "ui:^1.0.0",
    "listbox": "listbox:^1.0.0"
  },
  "resolvedPacks": {
    "ui": "mod://Turnix@ui:1.0.0",
    "listbox": "mod://Enter@listbox:1.0.0"
  }
}

Notes:

- requestedPacks stores PackRefStrings / PackRequests as originally requested by
  manifests (or generator.js logic).
- resolvedPacks stores the exact ResolvedPackId chosen at the time of save
  creation or last upgrade.


6.2 Load-time resolution and upgrade checks
-------------------------------------------

When loading a save:

1. For each entry in requestedPacks:
   - Use the corresponding selector (for example listbox:^1.0.0).

2. Use PackResolver to determine the current best candidate based on the
   available packs.

3. Compare with the stored resolvedPacks entry:
   - If they are identical, load that pack directly.
   - If they differ (for example, a newer version is now available that still
     satisfies ^1.0.0):
     - Prompt the user whether to upgrade to the new version.
     - If the user chooses to upgrade:
       - Attempt to load the new pack and run any validation.
       - If it is successful, update resolvedPacks in the save metadata and
         create a backup of the old state.
       - If it fails in a detectable way, revert to the previous version and
         inform the user.

4. If the pack referenced in resolvedPacks no longer exists:
   - This is an error; the save is no longer directly reproducible with the
     current installation.
   - The system may offer to re-resolve from requestedPacks, but must clearly
     indicate that behaviour is no longer guaranteed identical.


------------------------------------------------------------
7. Worked examples
------------------------------------------------------------


7.1 Main menu bootstrap
-----------------------

Default startup sequence when no --loadSave and no --createAppPack are
provided:

1. Try to load:

   appPack://Turnix@main-menu/saves

2. ResourceUriResolver maps this to:

   <root>/first-party/appPacks/main-menu/saves/manifest.json5

3. If this manifest does not exist:
   - Fallback to appPack://Turnix@main-menu.
   - Load <root>/first-party/appPacks/main-menu/manifest.json5.
   - Read fields such as:

     {
       "kind": "appPack",
       "author": "Turnix",
       "id": "main-menu",
       "name": "Main Menu",
       "version": "1.0.0",
       "defaultInstanceId": "turnix-main-menu",
       "overrideSaveUri": "appPack://Turnix@main-menu/save/",
       "packs": {
         "main-menu-ui": "^1.0.0",
         "toast": "^1.0.0"
       }
     }

   - Run generator.js to create a save (or a savePack) and initialize
     resolvedPacks based on the manifest and discovered packs.
   - Respect read-only rules on <root>/first-party paths and redirect actual
     writable output to saves/ or userdata/ as needed, while still maintaining
     logical overrideSaveUri semantics.

4. Once the save is created, load it using the savePack semantics and normal
   resolution rules.


7.2 100floors uses ui mod
-------------------------

100floors application pack manifest:

{
  "kind": "appPack",
  "author": "Turnix",
  "id": "100floors",
  "name": "100floors",
  "description": "A 100 floors dungeon example.",
  "version": "1.0.0",
  "app": {
    "runtimes": {
      "javascript": {
        "generator": "generator.js",
        "entry": "src/100floors.js"
      }
    },
  }
  "packs": {
    "ui": "^1.0.0"
  }
}

ui mod manifest:

{
  "kind": "mod",
  "author": "Turnix",
  "id": "ui",
  "name": "Basic UI",
  "description": "Provides basic UI for application packs.",
  "version": "1.0.0",
  "mod": {
    "runtimes": {
      "javascript": {
        "entries": [
          "button.js",
          "textarea.js",
          "menu.js",
          "dialog.js",
          "messageslist.js"
        ]
      }
    }
  }
}

Resolution flow for "ui": "^1.0.0":

1. Parse selector: packId = "ui", versionSpec = "^1.0.0", no explicit author.
2. ScopeResolver:
   - Local scope in 100floors: no embedded ui mod.
   - Global scope: candidates from PackDescriptorRegistry:
     - mod://Turnix@ui:1.0.0
3. VersionChooser:
   - Only one candidate, version 1.0.0, which matches ^1.0.0.
4. PackResolver returns:
   - ResolvedPackId = "mod://Turnix@ui:1.0.0".
5. Save metadata records:
   - requestedPacks["ui"] = "ui:^1.0.0"
   - resolvedPacks["ui"] = "mod://Turnix@ui:1.0.0"


7.3 trace-monitor and listbox versions
--------------------------------------

trace-monitor view pack manifest:

{
  "kind": "viewPack",
  "author": "Turnix",
  "id": "trace-monitor",
  "name": "Trace Monitor",
  "version": "1.0.0",
  "packs": {
    "ui": "^1.0.0",
    "listbox": "^1.0.0"
  }
}

Listbox mod manifests:

// Enter's listbox
{
  "kind": "mod",
  "author": "Enter",
  "id": "listbox",
  "name": "listbox",
  "description": "Scrollable list of items.",
  "version": "1.0.0"
}

// Jan's listbox v2
{
  "kind": "mod",
  "author": "Jan",
  "id": "listbox",
  "name": "listbox v2",
  "description": "Buffed listbox with filters.",
  "version": "1.1.0",
  "extends": "Enter@listbox" // optional inheritance metadata
}

(Example above uses an extra "extends" field as custom metadata; it has no
behaviour in the core specs and is interpreted only by higher-level tools.)

When first loading trace-monitor in a world where only Enter's listbox exists:

1. Selector: "listbox": "^1.0.0".
2. ScopeResolver → candidates:
   - mod://Enter@listbox:1.0.0.
3. VersionChooser → choose 1.0.0.
4. Save metadata:
   - requestedPacks["listbox"] = "listbox:^1.0.0"
   - resolvedPacks["listbox"] = "mod://Enter@listbox:1.0.0"

Later, Jan's listbox:1.1.0 is installed:

1. On save load, the engine again evaluates requestedPacks["listbox"]:
   - Candidates now:
     - mod://Enter@listbox:1.0.0
     - mod://Jan@listbox:1.1.0
2. VersionChooser:
   - Both satisfy ^1.0.0.
   - Policy chooses the highest version: 1.1.0 (Jan's).
3. Because this differs from stored resolvedPacks["listbox"]
   (Enter@listbox:1.0.0):
   - Prompt the user to upgrade.
   - On acceptance, attempt to load Jan's listbox.
   - If successful, update resolvedPacks["listbox"] to
     "mod://Jan@listbox:1.1.0" and create a backup of the previous save state.

This behaviour ensures that saves can evolve to newer compatible versions while
still allowing explicit control and rollback.


------------------------------------------------------------
8. Summary of components for implementation
------------------------------------------------------------

For code generation or manual implementation, the following main components are
required:

1. PackRequestParser
   - Parses <author?>@<packTreeId>[@<SemVerPackRequirement>] into structured
     data compatible with PackRequest.

2. PackDescriptorRegistry
   - Discovers packs on disk.
   - Indexes them by kind, author, packTreeId, and exactVersion.

3. VersionChooser
   - Given a version spec and a list of exact versions, chooses the best match
     or reports failure.

4. ScopeResolver
   - Implements local-then-global search for packs embedded inside other packs.

5. PackResolver
   - Combines selector parsing, scope resolution, and version choice to produce
     a ResolvedPackId and a concrete pack entry.

6. ResourceUriResolver
   - Handles complete URIs (scheme + author + packId/directories + inner paths)
     and returns filesystem paths.

7. SaveManifestManager
   - Writes and reads requestedPacks and resolvedPacks sections in save manifests.
   - Provides helpers to iterate over requested dependencies.

8. UpgradeManager
   - Compares stored resolvedPacks with current resolution results.
   - Decides when to prompt for upgrade.
   - Applies upgrades and manages backups.

All higher-level behaviour (application bootstrapping, generator execution,
AppInstance management) is expected to use these components rather than bypass
them, to keep behaviour consistent across Turnix.
