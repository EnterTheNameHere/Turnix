TURNIX PACK DISCOVERY, RESOLUTION & ACTIVATION PHASES
=====================================================
Version: Current (2025-12)
Status: Drafted for internal documentation
Authority: 
  - pack-manifest-structure.txt
  - pack-and-asset-resolution.txt
  - roots-and-discovery.txt
  - pack-uri-spec.txt

This document consolidates the operational phases of Turnix according to the
latest canonical specifications. It defines the lifecycle from filesystem
scanning to activation of appPacks, viewPacks, and mods. It is intended as a
reference for developers and tooling.


=====================================================
0. OVERVIEW
=====================================================

Turnix has three major operational stages:

  1. DISCOVERY — scan roots → build PackDescriptors → finalize registry
  2. RESOLUTION — convert PackRequests into ResolvedPacks
  3. ACTIVATION — load appPack, views, and mods; run generators; initialize runtime

Discovery happens at backend startup or when rescanning.  
Resolution and Activation occur per appInstance, per view, or per mod.

Resolution MUST NOT access the filesystem.  
Discovery MUST complete before any resolution is performed.


=====================================================
1. DISCOVERY PHASE
=====================================================

Discovery is responsible for building the complete PackDescriptorRegistry.  
It consists of four sub-phases that run in strict order.

----------------------------
1.1 Discovery.ScanRoots
----------------------------

- Traverse the effective set of content roots:
      first-party/
      third-party/
      custom/
      saves/

- Follow the rules in roots-and-discovery.txt:
    • identify directories containing manifest.json5  
    • treat each such directory as a packRoot  
    • recursively search inside each packRoot for nested packs  
    • do not scan userdata/  
    • path traversal must not escape roots  
    • symlink rules apply if enabled  

- For each discovered manifest, schedule descriptor construction.

----------------------------
1.2 Discovery.BuildDescriptors
----------------------------

For each detected packRoot:

- Load and parse manifest.json5.
- Construct a PackDescriptor according to pack-and-asset-resolution.txt:
      localId
      packTreeId (computed hierarchy)
      declaredAuthor, declaredVersion
      effectiveAuthor, effectiveVersion
      kind
      visibility, globalVisibility
      exportNestedPacks
      importPacksFromParent
      assets
      runtimeEntries
      recommended/supported/unsupported pack requests

- Enforce manifest structure rules:
      id constraints
      kind validity
      inheritance rules
      visibility defaults
      author/version inheritance

- Build parent–child relationships for nested packs.

----------------------------
1.3 Registry.FinalizeSnapshot
----------------------------

- Construct a PackDescriptorRegistry from all PackDescriptors.
- Create indexes:
      by packTreeId
      by (effectiveAuthor, packTreeId)
      by (effectiveAuthor, packTreeId, exactVersion)
- Validate collisions and invariants.
- Freeze registry: no further descriptors may be added until next rescan.

----------------------------
1.4 Registry.Ready
----------------------------

- The system now has a complete, immutable snapshot of all available packs.
- Resolution may begin.
- No filesystem scanning is permitted during resolution or activation.


=====================================================
2. RESOLUTION PHASE
=====================================================

Resolution interprets PackRequests and Pack URIs.  
It cannot touch the filesystem and must use only the PackDescriptorRegistry.

Resolution involves three conceptual components:

- ScopeResolver (local-before-global lookup)
- VersionChooser (semver matching)
- PackResolver (full selection and ResolvedPack construction)

This phase is implicitly triggered by ACTIVATE operations.

No explicit lifecycle stages exist here; resolution is on-demand.


=====================================================
3. ACTIVATION PHASE
=====================================================

Activation loads and initializes runnable components: appPacks, viewPacks, mods.

Activation is structured into multiple stages executed in order.


-----------------------------------------------------
3.1 Activation.LoadAppPack
-----------------------------------------------------

Triggered when Turnix is asked to boot into an application.

- Interpret resource URI: appPack://author@packTreeId[:version]
- Use PackResolver to select a PackDescriptor.
- Validate kind == "appPack".
- Load PackDescriptor.runtimeEntries for Python (backend) immediately.
- Prepare viewPack/contentPack/mod dependencies for resolution.

This stage selects the definitive appPack for this process.


-----------------------------------------------------
3.2 Activation.BuildAppInstance
-----------------------------------------------------

Construct a new AppInstance using:

- appPack metadata  
- declared dependencies ("packs" section)
- automatic dependency inheritance (importPacksFromParent)
- scope rules (local embedded packs override global ones)
- PackResolver over the complete dependency graph

All packs required by the appPack are now mapped to exact versions and
associated PackDescriptors.

Initialize:

- memory layers
- initial configuration
- mod loading plan
- view definitions

At the end, dependency resolution is complete.


-----------------------------------------------------
3.3 Activation.RunGenerator (optional)
-----------------------------------------------------

Executed when:

- no savePack exists for the chosen appPack, OR
- appPack explicitly declares generator behavior.

Steps:

1. Load appPack JS/Python generator runtime entries.
2. Execute generator to create a savePack structure.
3. Save created pack under:
       saves/<appPackId>/<appInstanceId>/
4. Record:
       requestedPacks
       resolvedPacks
       modOrder

SavePack participates in discovery for subsequent launches and overrides
external packs of the same identity.


-----------------------------------------------------
3.4 Activation.AppReady
-----------------------------------------------------

Completed when:

- AppInstance exists
- SavePack is loaded (existing or newly generated)
- All dependencies resolved to exact versions
- Python backend mods for the appPack are ready
- runtime entries for appPack have been executed

The application is now considered "running".


=====================================================
4. VIEW ACTIVATION PHASE
=====================================================

Each viewId triggers an isolated activation flow.

-----------------------------------------------------
4.1 Activation.LoadViewPack
-----------------------------------------------------

- Resolve the viewPack declared for a viewKind.
- Resolve its dependency graph (mods, contentPacks).
- Load Python backend runtimeEntries.
- Prepare frontend runtimeEntries (JavaScript) for delivery.

Views may have nested private packs ignored by global registry.


-----------------------------------------------------
4.2 Activation.ProvideViewResources
-----------------------------------------------------

Triggered when the frontend connects.

- Use ResourceUriResolver to serve JS modules, assets, schemas.
- Ensure globalVisibility rules are enforced:  
  only exported packs may be resolved globally.

When frontend receives its scripts, it can begin loading JS mods.


=====================================================
5. MOD ACTIVATION PHASE
=====================================================

Mods contain Python runtimeEntries and/or JavaScript runtimeEntries.

These are activated separately.

-----------------------------------------------------
5.1 Activation.Mod.ResolveRuntimeEntries
-----------------------------------------------------

Determine:

- python entries
- javascript entries

Validate mod kind and metadata.

Build ModEntry object for backend and prepare frontend manifest.


-----------------------------------------------------
5.2 Activation.Mod.LoadPython
-----------------------------------------------------

- Import module(s)
- Execute mod.onLoad(context)
- Register hooks into pipeline, AppInstance, views, etc.

Python mods always load first (backend never waits for frontend).

-----------------------------------------------------
5.3 Activation.Mod.LoadJavascript
-----------------------------------------------------

Executed when frontend is connected:

- Serve JS runtime entries via URI
- Initialize mod module on frontend
- Execute onLoad() on frontend side

-----------------------------------------------------
5.4 Activation.Mod.Ready
-----------------------------------------------------

A mod is considered fully activated when:

- Backend Python runtimeEntries loaded successfully
- Frontend JS entries loaded (if any)
- Hooks registered
- Initialization code complete

At this stage, the mod may participate in execution flow (pipelines, events,
RPC, views).


=====================================================
6. INVARIANTS
=====================================================

- Discovery MUST complete before resolution.  
- Resolution MUST NOT perform filesystem operations.  
- No pack loading may happen outside the Activation phase.  
- SavePack overrides external PackDescriptors for its AppInstance.  
- Frontend execution of mods must not precede backend initialization.  
- PackDescriptorRegistry MUST remain immutable until rescanning.


=====================================================
7. SUMMARY
=====================================================

Lifecycle overview:

  DISCOVERY
    → ScanRoots
    → BuildDescriptors
    → FinalizeSnapshot
    → Registry.Ready

  ACTIVATION (APP)
    → LoadAppPack
    → BuildAppInstance
    → RunGenerator (optional)
    → AppReady

  ACTIVATION (VIEW)
    → LoadViewPack
    → ProvideViewResources

  ACTIVATION (MOD)
    → ResolveRuntimeEntries
    → LoadPython
    → LoadJavascript
    → ModReady

This model fully matches:
  pack-manifest-structure.txt,
  pack-and-asset-resolution.txt,
  roots-and-discovery.txt,
  and the Pack URI specification.
