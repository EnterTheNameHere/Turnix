===============================================================================
TURNIX PACK DISCOVERY, RESOLUTION, AND ACTIVATION PHASES
===============================================================================

Version: Current (2025-12)
Status: DRAFT (internal documentation, NOT AUTHORITATIVE)

Authority note:
This document is a consolidation reference only. In case of conflict, the
following documents are authoritative:

- pack-manifest-structure.txt
- pack-and-asset-resolution.txt
- roots-and-discovery.txt
- pack-uri-spec.txt

This document MUST NOT override authoritative specifications.


===============================================================================
1. SCOPE
===============================================================================

This document defines the operational lifecycle from filesystem scanning to
activation of appPacks, viewPacks, and mods.

It is intended for:
- developers implementing Turnix subsystems
- tooling authors (validators, inspectors, debug UIs)
- internal consistency checks and staging boundaries


===============================================================================
2. OVERVIEW
===============================================================================

Turnix has three operational stages:

1. DISCOVERY
   - Scan roots
   - Build PackDescriptors
   - Finalize PackDescriptorRegistry snapshot

2. RESOLUTION
   - Convert PackRequests and Pack URIs into ResolvedPacks

3. ACTIVATION
   - Load and initialize appPack, viewPacks, and mods
   - Run generators when required
   - Initialize runtime behavior

Discovery occurs at backend startup and during rescans.

Resolution and Activation occur per AppInstance, per view, or per mod.

Invariants:
- Discovery MUST complete before any resolution is performed.
- Resolution MUST NOT access the filesystem.


===============================================================================
3. DISCOVERY PHASE
===============================================================================

Discovery builds the complete PackDescriptorRegistry snapshot.

Discovery consists of four sub-phases that execute in strict order.


Discovery.ScanRoots
-------------------------------------------------------------------------------

- Traverse the effective set of content roots:
    first-party/
    third-party/
    custom/
    saves/

- Follow rules in roots-and-discovery.txt:
    - identify directories containing manifest.json5
    - treat each such directory as a packRoot
    - recursively search inside each packRoot for nested packs
    - do not scan userdata/
    - path traversal MUST NOT escape roots
    - symlink rules apply if enabled

- For each discovered manifest, schedule descriptor construction.


Discovery.BuildDescriptors
-------------------------------------------------------------------------------

For each detected packRoot:

- Load and parse manifest.json5.
- Construct a PackDescriptor according to pack-and-asset-resolution.txt,
  including at least:
    - localId
    - packTreeId (computed hierarchy)
    - declaredAuthor, declaredVersion
    - effectiveAuthor, effectiveVersion
    - kind
    - visibility, globalVisibility
    - exportNestedPacks
    - importPacksFromParent
    - assets
    - runtimeEntries
    - recommendedPacks, supportedPacks, unsupportedPacks

- Enforce manifest structure rules from pack-manifest-structure.txt:
    - id constraints
    - kind validity
    - inheritance rules
    - visibility defaults
    - author and version inheritance

- Build parent-child relationships for nested packs.


Registry.FinalizeSnapshot
-------------------------------------------------------------------------------

- Construct a PackDescriptorRegistry from all PackDescriptors.
- Create indexes (conceptual minimum set):
    - by packTreeId
    - by (effectiveAuthor, packTreeId)
    - by (effectiveAuthor, packTreeId, kind)
    - by (effectiveAuthor, packTreeId, kind, exactVersion)

- Validate collisions and invariants.
- Freeze the registry snapshot:
    - no further descriptors may be added until the next rescan


Registry.Ready
-------------------------------------------------------------------------------

- The system now has a complete, immutable snapshot of all available packs.
- Resolution may begin.
- No filesystem scanning is permitted during resolution or activation.


===============================================================================
4. RESOLUTION PHASE
===============================================================================

Resolution interprets PackRequests and Pack URIs.

Constraints:
- Resolution MUST NOT access the filesystem.
- Resolution MUST use only the PackDescriptorRegistry snapshot.

Resolution is composed of three conceptual components:

- ScopeResolver
  - performs local-before-global lookup rules
  - enforces SavePack override behavior for an AppInstance

- VersionChooser
  - performs semantic version matching and tie-breaking rules

- PackResolver
  - performs full selection and constructs ResolvedPack objects

Resolution is triggered by activation operations. Resolution is on-demand and
does not have a standalone lifecycle beyond the constraints above.


===============================================================================
5. ACTIVATION PHASE
===============================================================================

Activation loads and initializes runnable components:
- appPacks
- viewPacks
- mods

Activation is structured into ordered stages.


Activation.LoadAppPack
-------------------------------------------------------------------------------

Triggered when Turnix is asked to boot into an application.

- Interpret resource URI:
    appPack://author@packTreeId[:version]

- Use PackResolver to select a PackDescriptor.
- Validate kind == "appPack".
- Load PackDescriptor.runtimeEntries for Python (backend) immediately.
- Prepare viewPack, contentPack, and mod dependencies for resolution.

Outcome:
- A definitive appPack is selected for this AppInstance activation flow.


Activation.BuildAppInstance
-------------------------------------------------------------------------------

Construct a new AppInstance using:

- appPack metadata
- declared dependencies ("packs" field)
- dependency inheritance rules (importPacksFromParent)
- scope rules (SavePack and embedded packs override external packs)
- PackResolver over the complete dependency graph

At completion:
- all required packs are mapped to exact versions and selected PackDescriptors

Initialize:
- memory layers
- initial configuration
- mod loading plan
- view definitions

Invariant:
- dependency resolution is complete at the end of this stage.


Activation.RunGenerator (optional)
-------------------------------------------------------------------------------

Executed when at least one of the following is true:
- no SavePack exists for the chosen appPack and AppInstanceId
- appPack declares generator behavior that requires execution

Steps:
1. Load appPack generator runtime entries (JavaScript and or Python).
2. Execute generator to create SavePack structure.
3. Save created pack under:
       saves/<appPackId>/<appInstanceId>/
4. Record at minimum:
       requestedPacks
       resolvedPacks
       modOrder

SavePack behavior:
- The created SavePack participates in discovery for subsequent launches.
- The SavePack overrides external packs of the same identity for the target
  AppInstance.


Activation.AppReady
-------------------------------------------------------------------------------

Completed when all of the following are true:

- AppInstance exists
- SavePack is loaded (existing or newly generated)
- all dependencies are resolved to exact versions
- Python backend mods required by the AppInstance are ready
- runtime entries for the appPack have executed as required

Outcome:
- The application is considered running for this AppInstance.


===============================================================================
6. VIEW ACTIVATION PHASE
===============================================================================

Each viewId triggers an isolated activation flow.


Activation.LoadViewPack
-------------------------------------------------------------------------------

- Resolve the viewPack declared for the target viewKind.
- Resolve its dependency graph (mods, contentPacks).
- Load Python backend runtimeEntries.
- Prepare frontend runtimeEntries (JavaScript) for delivery.

Visibility note:
- Views MAY have nested private packs.
- Global resolution MUST enforce globalVisibility rules defined by authoritative
  specifications.


Activation.ProvideViewResources
-------------------------------------------------------------------------------

Triggered when the frontend connects.

- Use ResourceUriResolver to serve:
    - JavaScript modules
    - assets
    - schemas or other frontend-needed resources

- Enforce globalVisibility:
    - only exported packs may be resolved globally

Outcome:
- The frontend receives scripts and resources and can begin loading JavaScript
  mods for the view.


===============================================================================
7. MOD ACTIVATION PHASE
===============================================================================

Mods contain Python runtimeEntries and or JavaScript runtimeEntries.

Mods are activated in separate stages.


Activation.Mod.ResolveRuntimeEntries
-------------------------------------------------------------------------------

Determine:
- python entries
- javascript entries

Validate:
- kind == "mod"
- required metadata for declared runtimes

Build:
- backend ModEntry object
- frontend mod manifest data (for delivery)


Activation.Mod.LoadPython
-------------------------------------------------------------------------------

- Import module or modules.
- Execute mod.onLoad(context).
- Register hooks into pipelines, AppInstance, views, and other subsystems.

Invariant:
- Python mods load before frontend mod initialization.


Activation.Mod.LoadJavascript
-------------------------------------------------------------------------------

Executed when the frontend is connected:

- Serve JavaScript runtime entries via URI resolution.
- Initialize mod module on frontend.
- Execute frontend onLoad(context) or equivalent lifecycle hook.


Activation.Mod.Ready
-------------------------------------------------------------------------------

A mod is considered fully activated when all applicable items are true:

- backend Python runtimeEntries loaded successfully (if any)
- frontend JavaScript runtimeEntries loaded successfully (if any)
- hooks registered
- initialization complete

Outcome:
- The mod may participate in execution flow (pipelines, events, RPC, views).


===============================================================================
8. INVARIANTS
===============================================================================

- Discovery MUST complete before resolution.
- Resolution MUST NOT perform filesystem operations.
- No pack loading may happen outside the Activation phase.
- SavePack overrides external PackDescriptors for its AppInstance.
- Frontend execution of mods MUST NOT precede backend initialization.
- PackDescriptorRegistry MUST remain immutable until rescanning.


===============================================================================
9. SUMMARY
===============================================================================

Lifecycle overview:

DISCOVERY
- ScanRoots
- BuildDescriptors
- FinalizeSnapshot
- Registry.Ready

ACTIVATION (APP)
- LoadAppPack
- BuildAppInstance
- RunGenerator (optional)
- AppReady

ACTIVATION (VIEW)
- LoadViewPack
- ProvideViewResources

ACTIVATION (MOD)
- ResolveRuntimeEntries
- LoadPython
- LoadJavascript
- Mod.Ready

This consolidation model is derived from:
- pack-manifest-structure.txt
- pack-and-asset-resolution.txt
- roots-and-discovery.txt
- pack-uri-spec.txt


===============================================================================
END OF FILE
===============================================================================
