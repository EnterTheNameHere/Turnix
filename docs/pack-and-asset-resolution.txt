===============================================================================
TURNIX PACK AND ASSET RESOLUTION SPECIFICATION
===============================================================================

Status: DRAFT (NOT AUTHORITATIVE)

Overview:
This specification defines:

- How packs are discovered and represented (PackDescriptor).
- How references to packs are written by creators (PackRefString, PackRequest).
- How semantic versioning is used for packs (SemVerPackVersion, requirements).
- How assets are declared and resolved via the manifest "assets" field.
- Constraints and invariants (no lazy discovery during resolution).

Authority note:
- Manifest shape, defaults, and field semantics are defined in:
    docs/pack-manifest-structure.txt
- Root layout and discovery order are defined in:
    roots-and-discovery.txt
- Filesystem scope enforcement and I/O rules are defined in:
    permissions-and-io-policy.txt
- Frontend-visible file serving rules are defined in:
    frontend-file-exposure-policy.txt

This document focuses on resolution and runtime handling and MUST remain
consistent with the above documents. This document MUST NOT override them.


===============================================================================
1. TERMINOLOGY
===============================================================================

Pack kinds (manifest field "kind"):
- "appPack"
- "viewPack"
- "mod"
- "contentPack"
- "savePack"

Root layers (discovery sources):
- first-party
- third-party
- custom
- saves

Pack directory:
- A directory that contains a manifest file (for example manifest.json5).
- That directory is the root of a pack tree for that pack.

Discovery:
- The scan or rescan phase that builds PackDescriptor entries from manifests
  and directory layout.

Resolution:
- The phase that answers PackRequests using only the PackDescriptor registry.

Asset:
- A file owned by a pack and declared as eligible for asset APIs by the
  manifest "assets" field and engine safe rules.


===============================================================================
2. SEMVER TERMINOLOGY
===============================================================================

SemVerPackVersion:
- A semantic version string declared in a pack manifest.
- Examples: "1.0.0", "2.5.3", "0.1.0-alpha.1".

SemVerPackRequirement:
- A semantic version range requested by a dependency or by a PackRefString.
- Examples: "^2.5.0", ">=1.2 <2.0", "2.5.3", "*".
- If omitted, it is treated as no constraint, meaning any version.

SemVerMatchResult:
- Result of matching multiple SemVerPackVersion values against one
  SemVerPackRequirement.
- Contains:
    kind: "none", "single", or "multiple"
    matches: list of PackDescriptor or (version, PackDescriptor) pairs

SemVerResolver:
- Component responsible only for matching versions.

Conceptual signature:
    match(
        candidates: list of (SemVerPackVersion, PackDescriptor),
        requirement: SemVerPackRequirement | None
    ) -> SemVerMatchResult


===============================================================================
3. IDENTITY TERMINOLOGY
===============================================================================

There are three id-related levels:

3.1 PackLocalId (manifest-level id)
-----------------------------------

- Value of "id" in the manifest.
- Local to the pack tree; used as one segment in a hierarchical id.

Constraints:
- MUST NOT contain '@'.
- MUST NOT contain a semantic version string.
- MUST NOT contain '.' (dot). Dots are reserved for hierarchy construction.

Examples:
- "ui"
- "trace"
- "trace-view"


3.2 packTreeId (hierarchical id)
--------------------------------

- Hierarchical dotted name built from PackLocalId values along the parent chain.
- Constructed during discovery and PackDescriptor building.

Rules:
- Root pack: packTreeId = PackLocalId
- Child:     packTreeId = parent.packTreeId + "." + localId

Examples (contentPack "ui", mod "trace", mod "trace-view"):
- "ui"                  (root)
- "ui.trace"            (child of ui)
- "ui.trace.trace-view" (child of trace)


3.3 PackRefString (creator-written reference string)
----------------------------------------------------

- What creators write in manifests to refer to other packs.

Grammar:
- "<author?>" "@" "<packTreeId>" ["@" "<SemVerPackRequirement>"]

Examples:
- "ui"                               (no author, no version requirement)
- "Anthony@avatars"                  (author + id)
- "Turnix@ui.trace.trace-list@2.5.3" (author + id + exact version)
- "Turnix@main-menu.ui@^3"           (author + id + version range)


===============================================================================
4. PACK REPRESENTATION (PackDescriptor)
===============================================================================

PackDescriptor is an immutable catalog entry for a single discovered pack.
It is created during discovery (scan or rescan). It MUST NOT be modified during
resolution.

Fields (conceptual):

    PackDescriptor:
        localId: PackLocalId
        packTreeId: str
        kind: str

        declaredAuthor: str | None
        declaredSemVerPackVersion: SemVerPackVersion | None

        effectiveAuthor: str
        effectiveSemVerPackVersion: SemVerPackVersion

        isVersionAgnostic: bool

        layer: "first-party" | "third-party" | "custom" | "saves"
        baseRoot: Path
        packRoot: Path
        manifestPath: Path

        parent: PackDescriptor | None

        visibility: "public" | "private"
        globalVisibility: "public" | "private"

        importPacksFromParent: bool
        exports: dict | None
        exportNestedPacks: bool | list of str

        recommendedPacks: list of PackRequest
        supportedPacks: list of PackRequest
        unsupportedPacks: list of PackRequest

        assets: dict of (str -> AssetMeta)
        runtimeEntries: dict of (str -> list of Path)

        name: str
        description: str | None
        authorName: str | None

        rawJson: Mapping of (str -> Any)

AssetMeta (conceptual):

    AssetMeta:
        logicalName: str
        relPath: Path
        kind: str

Effective author and version:

effectiveAuthor:
- If manifest declares "author": use it.
- Else if parent exists: inherit parent.effectiveAuthor.
- Else: engine assigns "unknown" or another engine-defined sentinel.

effectiveSemVerPackVersion:
- If manifest declares "version": use it.
- Else if parent exists: inherit parent.effectiveSemVerPackVersion.
- Else: use an engine-defined default version.
  The exact default and its meaning are defined by the manifest authority spec.

isVersionAgnostic:
- Optional semantic flag meaning the pack conceptually serves all versions.
- Used by SemVerResolver as a priority hint when multiple candidates exist.
- This flag MAY be omitted in initial implementations.

IMPORTANT:
- PackDescriptor construction MUST obey:
    - roots-and-discovery.txt
    - docs/pack-manifest-structure.txt
- Filesystem paths in PackDescriptor MUST be validated through IoManager rules
  (see permissions-and-io-policy.txt).


===============================================================================
5. PACK REQUESTS (PackRefString, PackRequest)
===============================================================================

PackRefString:
- Raw string written in a manifest to depend on a pack.

Grammar:
- [<author> "@"] <packTreeId> ["@" <SemVerPackRequirement>]

Examples:
- "avatars"
- "Anthony@avatars"
- "Turnix@ui.trace.trace-list@2.5.3"
- "Turnix@main-menu.ui@^3"

PackRequest (parsed form):

    PackRequest:
        author: str | None
        packTreeId: str
        semverRequirement: SemVerPackRequirement | None
        kind: str | None

Examples:

- "Anthony@avatars"
    -> PackRequest(author="Anthony",
                   packTreeId="avatars",
                   semverRequirement=None,
                   kind=None)

- "Turnix@ui.trace.trace-list@2.5.3"
    -> PackRequest(author="Turnix",
                   packTreeId="ui.trace.trace-list",
                   semverRequirement="2.5.3",
                   kind=None)

Normalization rules:
- PackRequestRef forms defined by the manifest structure spec MUST normalize
  into PackRequest instances.
- A missing author is a wildcard.
- A missing semverRequirement is a wildcard.
- A missing kind is a wildcard.


===============================================================================
6. DISCOVERY PHASE (SCAN TO PackDescriptor REGISTRY)
===============================================================================

There are exactly two phases:
- Phase 1: Discovery (scan or rescan).
- Phase 2: Resolution (respond to PackRequests).

Invariants:
- Discovery builds or updates a complete PackDescriptor registry snapshot.
- Resolution MUST NOT trigger filesystem scanning or manifest probing.
- Resolution MUST use only a single registry snapshot.

Discovery steps (high level):

1. For each discovery layer:
   - first-party, third-party, custom:
       - Scan immediate subdirectories only, as defined by roots-and-discovery.
   - saves:
       - Scan SavePack trees as defined by roots-and-discovery.

2. When a manifest file is found in a directory:
   - Treat that directory as a pack root.
   - Create a PackDescriptor for the root pack.
   - Search inside that directory for nested packs with their own manifests.

3. For each pack discovered:
   - Read manifest at least for:
       id, author, version, kind, visibility, exportNestedPacks,
       importPacksFromParent, exports, packs, assets,
       recommendedPacks, supportedPacks, unsupportedPacks, name, description.
   - Determine parent PackDescriptor (if any).
   - Compute:
       localId = manifest.id
       packTreeId:
           if parent is None: packTreeId = localId
           else: packTreeId = parent.packTreeId + "." + localId

       effectiveAuthor:
           declaredAuthor or parent.effectiveAuthor or engine sentinel

       effectiveSemVerPackVersion:
           declaredSemVerPackVersion
           or parent.effectiveSemVerPackVersion
           or engine default

       visibility:
           if manifest.visibility is "public" or "private": use it
           else:
               kind == "contentPack" -> "public"
               kind in {"appPack","viewPack","mod","savePack"} -> "private"

       exportNestedPacks:
           if manifest.exportNestedPacks is boolean: use it
           if manifest.exportNestedPacks is array: use list of child PackLocalId
           else:
               kind == "contentPack" -> true
               kind in {"appPack","viewPack","mod","savePack"} -> false

       globalVisibility:
           if parent is None:
               globalVisibility = visibility
           else if visibility == "private":
               globalVisibility = "private"
           else if parent.exportNestedPacks == false:
               globalVisibility = "private"
           else if parent.exportNestedPacks == true:
               globalVisibility = "public"
           else if parent.exportNestedPacks is a list:
               globalVisibility = "public" if localId is in that list
               else "private"

       importPacksFromParent:
           manifest.importPacksFromParent if present else default
           default is false for viewPack, true otherwise

       exports:
           manifest.exports or None

       recommendedPacks, supportedPacks, unsupportedPacks:
           normalize each from manifest field values using the same rules as
           "packs" normalization into PackRequest instances, or [] if missing.

   - Build runtimeEntries (implementation-defined; may be eager or cached).
   - Process "assets" (see section 7) and fill PackDescriptor.assets.

4. Register all PackDescriptor objects into a PackDescriptorRegistry.

Registry query capabilities:
- MUST support query by packTreeId.
- MUST support query by (effectiveAuthor, packTreeId, kind).
- MUST support query by (effectiveAuthor, packTreeId, kind,
  effectiveSemVerPackVersion).

No lazy discovery rule:
- Once discovery finishes, every pack that exists under discovery roots MUST
  appear in the PackDescriptorRegistry snapshot.
- Resolution MUST NOT trigger filesystem traversal or manifest probing.

I/O policy interaction:
- All manifest reading and directory scanning MUST occur through IoManager.
- Any direct filesystem access outside IoManager is an implementation mistake
  (see permissions-and-io-policy.txt).


===============================================================================
7. ASSET DECLARATION (manifest "assets" field)
===============================================================================

Goal:
- Allow creators to expose directories of assets without listing each file.
- Auto-include only files with safe extensions.
- Allow explicit inclusion of non-safe file types.

Manifest key: "assets"

Type (conceptual):

    "assets": [
        "<dir-string>" | {
            "dir": "<directory>",
            "files": [ "<relative-file-or-subpath>", ... ],
            "safeAuto": bool (optional, default true)
        },
        ...
    ]

String form example:
    "assets": ["assets", "images/portraits"]

String form semantics:
- Each string entry is a directory path relative to pack root.
- At discovery, engine walks the directory recursively.
- Engine auto-includes all files with safe extensions into PackDescriptor.assets.

Object form example:
    "assets": [
        {
            "dir": "raw-avatars",
            "files": ["avatar.dat", "special/mesh.bin"]
        }
    ]

Object form semantics:
- dir: directory base path relative to pack root.
- files: list of paths relative to dir that are explicitly included even if the
  extension is not safe.
- safeAuto (optional, default true):
    - true: include safe files under dir automatically, plus files in "files".
    - false: include ONLY the listed "files" from that dir.

Safe extensions:
- Engine-defined list, for example:
    Images:  .png, .jpg, .jpeg, .webp, .gif
    Text:    .txt, .json, .json5, .yml, .yaml, .toml, .ini, .csv, .tsv
    Audio:   .wav, .ogg (optional, if engine declares safe)

Unknown or unsafe extensions:
- MUST NOT be auto-included.
- MUST be included only if explicitly listed in an object entry "files" list.

PackDescriptor.assets construction (simplified):

    For each assets entry:
        if entry is a string dirPath:
            recursively scan dirPath
            for each file:
                if extension is in safe list:
                    logicalName = filename or relative path alias
                    assets[logicalName] = AssetMeta(...)

        if entry is an object:
            if safeAuto is true or missing:
                include safe files under dir
            for each file in files:
                include that file regardless of extension

Assets namespace rules:
- By default, logicalName is the filename (for example "Sandy.png").
- If multiple assets share a logicalName, the pack context disambiguates.
- Engine MAY implement a stable aliasing strategy based on relative paths.

Frontend serving interaction:
- PackDescriptor.assets defines what the asset APIs may access.
- Frontend-visible serving MUST also obey frontend-file-exposure-policy.txt.
- A file MUST NOT be served to frontend solely because it is an asset.


===============================================================================
8. RESOLUTION PHASE (PackResolver)
===============================================================================

PackResolver resolves PackRequest into a ResolvedPack using only the registry.

ResolvedPack (conceptual):

    ResolvedPack:
        meta: PackDescriptor
        sourceLayer: str
        replaced: list of PackDescriptor

        author: str
        packTreeId: str
        semverPackVersion: SemVerPackVersion
        kind: str

        baseRoot: Path
        packRoot: Path
        manifestPath: Path

        runtimeEntries: dict of (str -> list of Path)
        assets: dict of (str -> AssetMeta)

Resolution steps (conceptual):

    resolvePack(request: PackRequest, registry: PackDescriptorRegistry)
        -> ResolvedPack:

        1. Filter by packTreeId, author, kind.

        2. SemVer filtering:
           match candidates against request.semverRequirement.

        3. Interpret SemVerMatchResult:
           - "none"      -> ResolutionError("No matching version")
           - "multiple"  -> ResolutionError("Ambiguous version")
           - "single"    -> select winning PackDescriptor

        4. Build ResolvedPack and return it.

Conceptual pseudocode:

    def resolvePack(request, registry):
        candidates = []
        for m in registry.all():
            if m.packTreeId != request.packTreeId:
                continue
            if request.author is not None and m.effectiveAuthor != request.author:
                continue
            if request.kind is not None and m.kind != request.kind:
                continue
            candidates.append(m)

        versionPairs = []
        for m in candidates:
            versionPairs.append((m.effectiveSemVerPackVersion, m))

        match = SemVerResolver.match(versionPairs, request.semverRequirement)

        if match.kind == "none":
            raise ResolutionError("No matching version")

        if match.kind == "multiple":
            raise ResolutionError("Ambiguous version")

        winner = match.matches[0]
        return ResolvedPack(meta=winner, sourceLayer=winner.layer, replaced=[])

No filesystem rule:
- Resolution MUST NOT read manifests.
- Resolution MUST NOT traverse directories.
- Resolution MUST NOT trigger discovery.


===============================================================================
9. ASSET RESOLUTION API (CONCEPTUAL)
===============================================================================

AssetRequest (conceptual):

    AssetRequest:
        pack: PackRequest or ResolvedPack
        assetName: str

Example (JavaScript runtime conceptual):
- A mod calls:
    ctx.assets.get("Sandy.png")

- The mod declares a dependency:
    packs: ["Anthony@avatars"]

- Pack resolution produces a ResolvedPack for "avatars".

AssetResolver (conceptual):

    def getAsset(resolvedPack, assetName):
        return resolvedPack.meta.assets.get(assetName)

Error behavior:
- If assetName is not found, the resolver MUST raise a clear error.
- Asset resolution MUST NOT scan the filesystem for missing assets.


===============================================================================
10. INVARIANTS AND ERROR CASES
===============================================================================

Discovery and rescan:
- MUST build a complete PackDescriptor registry snapshot for all packs under
  discovery roots.
- MUST detect collisions where:
    - two packs share the same
      (effectiveAuthor, packTreeId, kind, effectiveSemVerPackVersion)
      and both appear in the same precedence layer without an explicit override
      mechanism.
- MAY reject manifests with invalid or conflicting id, author, version, kind.

Resolution:
- MUST NOT touch filesystem or read manifests.
- MUST fail clearly if:
    - No PackDescriptor matches PackRequest packTreeId, author, kind filters.
    - SemVerResolver returns "none" or "multiple" for a request.
- PackRequests with missing author or missing semverRequirement MUST be treated
  as wildcards.

Assets:
- Only files present in PackDescriptor.assets may be served via asset APIs.
- Unknown extensions MUST NOT be served unless explicitly listed in an object
  entry "files" list.
- Asset APIs MUST enforce scope via IoManager and MUST deny traversal escapes.

End of specification (draft).


===============================================================================
END OF FILE
===============================================================================
