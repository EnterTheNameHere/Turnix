TURNIX TRACING STANDARD v0.1 (UPDATED TO MATCH CURRENT SPECS)

This document defines the wire format, conceptual model, lifecycle rules, and
required fields for the Turnix tracing system.

It is the canonical reference for tracing in pre-alpha.


======================================================================
1. CORE CONCEPTS
======================================================================

Tracing uses **spans** and **events**.

- A **span** represents an operation with start and end.
- An **event** is a point-in-time message inside a span.
- Missing spanEnd means the operation is still running or ended abnormally.

All trace records are **independent JSON objects** delivered through a single
stream (`/ws/trace`), one per message.

Tracing is used to understand:

- pipeline execution state
- RPC circulation
- AppInstance / session behavior
- mod hook behavior
- contentPack and asset loading performance
- memory updates inside MemoryLayers
- LLM request/response phases
- concurrency and cross-subsystem interactions


======================================================================
2. SPAN MODEL
======================================================================

Each span has:

- spanId
- traceId (groups related spans: RPC → pipeline → LLM → mod hook)
- parentSpanId (null or absent for roots)
- spanName (stable, identifier-free)
- status: "ok", "error", "cancelled"
- errorType (optional)
- errorMessage (optional)
- errorStack (optional)

A span produces:

- spanStart
- spanEnd

If spanEnd never arrives, the span is considered “open”.


======================================================================
3. EVENT MODEL
======================================================================

Events:

- attach to a span via spanId
- have eventName
- carry arbitrary structured attrs
- represent moments, not durations

When a span errors, the system produces:

1. spanEnd with status="error"
2. zero or more event records containing diagnosing details


======================================================================
4. RECORD TYPES & REQUIRED FIELDS
======================================================================

Each record has:

    recordType: "spanStart" | "spanEnd" | "event"

Global fields:

    time: ISO 8601 timestamp with milliseconds
    seq: monotonic integer per trace stream
    traceId: correlation id
    spanId: for all record types
    level: "debug" | "info" | "warn" | "error"
    tags: list of short strings
    attrs: object with structured metadata


======================================================================
5. CONTEXT FIELDS (ALIGNED WITH CURRENT TURNIX TERMINOLOGY)
======================================================================

Optional standardized fields:

    appInstanceId      — id of the AppInstance owning the operation
    sessionId          — id of the session tied to this view or RPC origin
    viewId             — id of the view where RPC originated, if applicable
    clientId           — stable long-term client identity (browser cookie)
    pipelineId         — pipeline name or kind
    pipelineRunId      — unique id for each run
    modId              — packTreeId or resolved mod id
    hookId             — identifier of specific hook handler
    rpcKind            — "inbound" | "outbound"
    llmProvider        — e.g. "llama.cpp"
    llmPreset          — preset/profile defined in PackDescriptor or runtime

These fields correspond to identifiers defined elsewhere in the framework
(AppInstance, Session, View, PackDescriptor).


======================================================================
6. spanStart RECORD
======================================================================

Example:

{
  "recordType": "spanStart",
  "time": "...",
  "seq": 0,
  "traceId": "...",
  "spanId": "...",
  "parentSpanId": null,
  "spanName": "pipeline.run",
  "appInstanceId": "...",
  "sessionId": "...",
  "pipelineRunId": "...",
  "level": "info",
  "tags": ["pipeline"],
  "status": null,
  "attrs": {
    "entryPoint": "user.chat"
  }
}

Rules:

- Emitted immediately when operation begins.
- status is always null for spanStart.
- spanName must be stable and must not encode identifiers.


======================================================================
7. spanEnd RECORD
======================================================================

Example:

{
  "recordType": "spanEnd",
  "time": "...",
  "seq": 1,
  "traceId": "...",
  "spanId": "...",
  "spanName": "pipeline.run",
  "appInstanceId": "...",
  "sessionId": "...",
  "pipelineRunId": "...",
  "level": "info",
  "tags": ["pipeline"],
  "status": "ok",
  "errorType": null,
  "errorMessage": null,
  "errorStack": null,
  "attrs": {
    "durationMs": 333.2
  }
}

Rules:

- Must contain a concrete status: ok, error, or cancelled.
- For status="error", all error fields must be populated.
- Missing spanEnd is treated as "unfinished".


======================================================================
8. event RECORD
======================================================================

Example:

{
  "recordType": "event",
  "time": "...",
  "seq": 2,
  "traceId": "...",
  "spanId": "spn-123",
  "eventName": "rpc.recv",
  "appInstanceId": "...",
  "sessionId": "...",
  "level": "debug",
  "tags": ["rpc", "inbound"],
  "attrs": {
    "method": "pipeline.startRun",
    "payloadSize": 852
  }
}

Rules:

- Must attach to a span via spanId.
- No status field.
- The primary tool for detailed diagnostic information.
- Should be used for all subsystem-specific events:
  - RPC (frame start, frame end, parse errors)
  - mod hook invocation steps
  - pipeline step transitions
  - LLM request/stream/response phases
  - memory operations inside MemoryLayers


======================================================================
9. STANDARD SPAN NAMES (UPDATED)
======================================================================

Canonical identifiers:

    "process.turnix"
        Lifecycle of backend process.

    "appInstance.lifecycle"
        A full lifecycle of one AppInstance.

    "session.lifecycle"
        Lifecycle of a session (defined in Session model).

    "pipeline.run"
        One execution of a pipeline run.

    "rpc.frame"
        Handling of a single inbound or outbound RPC frame.

    "mod.hook"
        Any mod hook invocation (view hooks, AppInstance hooks, pipeline hooks).

    "llm.call"
        One full model request/response.

    "memory.op"
        A single MemoryLayer operation (create/update/delete/load).

Rules:
- Never include identifiers inside the spanName.
- Context fields and attrs hold identifiers.


======================================================================
10. MEMORY OPERATION TRACING (ALIGNED WITH NEW MEMORYLAYERS)
======================================================================

Span name:

    memory.op

Required attrs:

    opKind: "create" | "update" | "delete" | "load"
    layerId: MemoryLayer name (for example: "party", "world", "session")
    itemRef: logical QueryItem reference ("npc.bartender", "quest.42", etc.)

Optional diff attrs:

    fieldsChanged
    hash.before / hash.after
    textPreview.before / textPreview.after

These allow trace viewers to show computed diffs, while the actual memory state
is retrieved via RPC.


======================================================================
11. LIFECYCLE RULES
======================================================================

Spans:

- spanStart must be emitted immediately.
- spanEnd must be emitted at completion.
- Missing spanEnd → considered running or abnormally terminated.

End status:

- "ok"         normal completion
- "error"      must include errorType, errorMessage, errorStack
- "cancelled"  intentional termination

Events:

- do not affect lifecycle.
- carry fine-grained details of what happened inside a span.


======================================================================
12. TRANSPORT AND STORAGE
======================================================================

This spec defines *only the data format*, not the transport mechanism.

Backend behavior:

- TraceHub aggregates spans/events.
- Messages placed into an in-memory ring buffer.
- Live messages pushed through `/ws/trace`.
- Must never block main operations.
- Must never throw into calling subsystems.

Optional:

- Viewer may save or load trace streams from disk.
- File I/O must not affect live tracing.


======================================================================
13. VERSIONING
======================================================================

This is **Turnix Tracing Standard v0.1**.

Rules:

- Pre-1.0: breaking changes allowed.
- 1.0+: schema becomes stable.
