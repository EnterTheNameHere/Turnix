===============================================================================
WEBSOCKET RPC FLOW
===============================================================================

This document explains how the Turnix backend wires the browser to the backend
over the /ws endpoint, and how RPCMessage envelopes travel across that socket.

It combines behavior from:
- the FastAPI WebSocket endpoint
- the Session manager
- the ViewRegistry
- the browser-side RpcClient implementation


===============================================================================
HTTP BOOTSTRAP BEFORE SOCKET OPEN
===============================================================================

Before the browser opens the WebSocket connection, it performs two HTTP
fetches that bootstrap configuration and establish identity.


1) Settings fetch
-----------------
Endpoint:
    GET /settings

Behavior:
- returns merged server configuration
- bootstrap script freezes the result onto:
      globalThis.Turnix

Purpose:
- allow early modules to read feature flags and environment switches
- works before RPC is available


2) View bootstrap
-----------------
Endpoint:
    POST /api/bootstrap

Behavior:
- issues or refreshes a clientId cookie
- binds the client to a view
- returns:
      - viewId
      - viewToken
      - current server generation number

Frontend behavior:
- stores these values
- includes them in the subsequent "hello" RPC payload
- also includes:
      - per-tab clientInstanceId
      - last persisted generation

Purpose:
- allow reconnects to resume cleanly
- prevent accidental cross-view binding


ViewRegistry responsibility:
- stores server-side viewToken
- ensures only the authenticated client can bind to a view
- allows:
      - multiple tabs sharing one clientId
      - distinct viewTokens per tab


===============================================================================
CONNECTION LIFECYCLE
===============================================================================

1) WebSocket upgrade
--------------------
The browser connects to:
    ws://.../ws  (or wss://...)

Backend behavior:
- endpoint registered via mountWebSocket
- after accept:
    - enter receive loop
    - discard non-text frames
    - enforce payload size limits
    - validate incoming frames as RPCMessage objects


2) Client hello
---------------
Immediately after WebSocket.OPEN, the frontend sends a "hello" frame.

Properties:
- includes view metadata
- uses:
    - standard schema version
    - sys lane
    - placeholder generation fields

Validation:
- helper enforces schema correctness before send


3) Welcome
----------
On the first valid "hello":

Backend behavior:
- resolve or create the view
- bind the WebSocket to that view
- allocate a new generation via:
      RPCConnection.newGeneration
- update view state

Response:
- send a "welcome" message containing:
      - new generation
      - snapshot of current view/session state


4) Client ready
---------------
After receiving "welcome":

Frontend behavior:
- marks the connection as ready
- flushes queued outbound messages
- resumes subscriptions
- reports module load status via "clientReady"

Backend behavior:
- ACK the message
- record module metadata
- ensure each module is processed only once per generation


5) Heartbeat
------------
Liveness is maintained bidirectionally.

Client:
- periodically sends heartbeat frames

Server:
- updates last-seen timestamp
- replies with ACK

Failure handling:
- missed heartbeats trigger frontend reconnection logic


6) Disconnect
-------------
When the socket closes:

Backend behavior:
- cancel all pending requests
- cancel active subscription coroutines
- remove view binding
- close the socket gracefully

Frontend behavior:
- clear timers
- reject pending Promises
- schedule exponential-backoff reconnect attempts


===============================================================================
SESSION AND GENERATION TRACKING
===============================================================================

RPCConnection maintains per-view/client state:

- idempotency cache
- pending request tasks
- active subscription coroutines
- generation metadata


Generation rules:
- each successful "hello" increments:
      - generation number
      - generation salt
- messages with mismatched generation MUST be ignored


Frontend responsibility:
- store the latest generation
- reject or discard any incoming message whose generation does not match


===============================================================================
MESSAGE DISPATCH
===============================================================================

After handshake completion:

Backend behavior:
- ACK every non-control message
- dispatch based on message type and route


Request messages:
- routed to:
      - object handlers, or
      - capability-based request handlers
- permissions enforced via:
      _ensureCapabilityOrError
- failures become structured "error" envelopes
- errors correlate to the original message


Emit / Subscribe messages:
- dispatched to capability handlers
- subscriptions tracked so that:
      - cancel
      - unsubscribe
  can halt the associated coroutine and remove it from Session state


Cancel messages:
- remove pending work
- stop active subscriptions


Frontend behavior:
- workload messages targeting capabilities are auto-ACKed
- messages are dispatched to:
      - call
      - emit
      - subscribe
  handlers
- replies and errors resolve or reject Promises
- subscription updates trigger local event emitters


===============================================================================
ACKNOWLEDGEMENTS AND FLOW CONTROL
===============================================================================

Automatic ACKs:
---------------
Backend:
- ACKs every message except:
      - ack
      - heartbeat

Frontend:
- ACKs all non-handshake messages

ACK contents:
- original message id
- sys lane routing


Budget and retry windows:
-------------------------
- request and emit helpers attach budgetMs
- derived from timeout and priority policy
- frontend tracks:
      - per-lane in-flight counters
      - per-lane queues
- additional messages are queued until:
      - ACK arrives
      - reply arrives

Purpose:
- prevent overload
- support best-effort cancellation on timeout


Idempotency:
------------
- request and emit helpers generate idempotencyKey
- server caches:
      - idempotencyKey
      - previous reply
- duplicate invocations:
      - return cached reply
      - do NOT re-run handlers


===============================================================================
PERMISSIONS AND PRINCIPALS
===============================================================================

Before invoking a capability handler:

Backend behavior:
- derive the principal from the message
- verify required capability permissions

Failure handling:
- produce structured error envelope
- include retry metadata
- allow frontend to present clear feedback


===============================================================================
LOGGING AND OBSERVABILITY
===============================================================================

Backend:
- serialize outbound frames using safeJsonDumps
- pass frames through the RPC logging decision engine
- logging is:
      - centralized
      - policy-controlled
      - lane-aware

Frontend:
- exposes equivalent logging hooks
- applies the same filtering rules

Result:
- coherent cross-side debugging
- no divergent logging semantics


===============================================================================
END OF WEBSOCKET RPC FLOW
===============================================================================


--- doc-meta ---
docId: docs/rpc/WEBSOCKET_RPC_FLOW.txt
rev: 10
git: da43ec8
----------------
