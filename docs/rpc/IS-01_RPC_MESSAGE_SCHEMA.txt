===============================================================================
IMPLEMENTATION SPECIFICATION 1 - RPC MESSAGE SCHEMA
===============================================================================

This document summarizes the structure of the RPC messages exchanged between
the frontend and backend.

The canonical model lives on the backend in:
    backend/rpc/models.py

It is mirrored on the frontend in:
    frontend/assets/types.d.ts
    RpcClient helper utilities


===============================================================================
CORE MODELS
===============================================================================

Model: Gen
-----------
Purpose:
Wraps the connection generation (num, salt) assigned by the server.

The Gen object is embedded in every RPC envelope so that both sides can
detect stale traffic and reject frames from previous sessions.


Model: Route
-------------
Purpose:
Points a message to either:
- a capability (capability)
- an object (object)

If the explicit lane is missing, the backend infers the default delivery
lane from the Route values.


Model: RPCMessage
-----------------
Purpose:
The wire envelope for all RPC communication.

Responsibilities:
- enforce camelCase aliases
- forbid extra fields
- validate message shape
- infer delivery lane via a model validator


===============================================================================
ENVELOPE FIELDS
===============================================================================

Unless stated otherwise, all fields are optional and default to null / None.

v (str)
-------
Schema version.
Currently "0.1".


id (str)
--------
UUIDv7 that uniquely identifies the message.


type (enum)
-----------
Message category.

Valid values:

Control messages:
- "hello"
- "welcome"
- "clientReady"
- "heartbeat"
- "ack"

Workload messages:
- "request"
- "emit"
- "reply"
- "subscribe"
- "stateUpdate"
- "unsubscribe"
- "cancel"
- "error"


correlatesTo (str)
------------------
Links this message to a parent message.

Used for:
- replies
- ACKs
- cancels
- error propagation


gen (Gen)
---------
Server-assigned generation.
Echoed by the client to validate session continuity.


ts (int)
--------
Monotonic send timestamp populated on creation.
For example, milliseconds since process start.


lane (str)
----------
Delivery lane.

Defaults:
- "sys" for control traffic
- for non-control messages, if empty it is inferred from route:
    - "cap:<capability>" when targeting a capability
    - "obj:<id>" when targeting a specific object

Lanes maintain independent sequencing and flow control per logical stream.


budgetMs (int)
--------------
Optional time budget for the operation in milliseconds.

Defaults are derived from protocol settings and priority classes.
Callers may override explicitly.


ackOf (int)
-----------
Reserved for richer ACK semantics.
Currently unused but retained for forward compatibility.


job (dict)
----------
Mirrors backend job progress snapshots when long-running work reports state.

The concrete structure is job-type specific.


idempotencyKey (str)
--------------------
Enables backend deduplication and cached replies.

For request and emit messages:
- helpers default this to the message id
- retries with the same id are naturally deduplicated


route (Route)
-------------
Target capability or object.

Mandatory for:
- request
- emit

Generally present for any workload message that requires routing.

Also used to:
- derive lanes
- enforce permissions


op (str)
--------
Operation qualifier.
For example: "call", "event".

Allows handlers to multiplex multiple behaviors on the same route.


path (str)
----------
Additional routing hint used by handlers to select an operation variant
or sub-endpoint.


args (list)
-----------
Positional arguments for capability calls initiated by the client.

For most RPC calls:
- payload carries structured data
- args is empty or contains a small number of positional parameters


seq (int)
---------
Per-lane delivery sequence number maintained by the sender.

Each lane has its own counter.


origin (dict)
-------------
Opaque metadata passed through without affecting permissions.

Typically includes:
- trace identifiers
- span identifiers
- calling context


chunkNo (int)
-------------
Index of the chunk when streaming payloads.

Starts at 0 or 1 depending on helper convention and is monotonically
increasing within the stream.


final (int | bool)
------------------
Marks the final chunk in a stream.

Accepts:
- boolean
- integer flag (non-zero treated as true)


payload (dict)
--------------
Application data.

Helpers enforce payload shape by message type:
- reply requires a result payload
- error requires an error object
- stateUpdate carries state deltas


===============================================================================
HELPER CONSTRUCTORS
===============================================================================

Backend helper functions construct validated envelopes while enforcing
required fields, correlating ids, and copying idempotency keys from the
triggering message.

This avoids hand-building envelopes across the codebase.


Typical helper responsibilities:

- set v to the current protocol version
- generate id (UUIDv7) for new messages
- copy correlatesTo for replies, ACKs, and cancels
- populate gen from the active RPCConnection
- compute lane if not provided, based on route and message type
- set default budgetMs for the operation kind
- copy idempotencyKey from the triggering message when applicable
- enforce required fields per message type


Per-type requirements:

- "hello"
    - MUST carry gen and client identity info in payload

- "request"
    - MUST carry route
    - MUST carry op and/or path
    - MUST carry payload or args as required

- "reply"
    - MUST carry correlatesTo
    - MUST carry payload

- "error"
    - MUST carry correlatesTo
    - MUST carry error payload


The frontend mirrors these helpers in RpcClient, guaranteeing symmetric
message shapes for:

- hello
- welcome
- clientReady
- heartbeat
- request
- emit
- subscribe
- unsubscribe
- cancel
- reply
- stateUpdate
- error
- ack

Both sides rely on shared defaults for:
- schema version
- system lane
- acknowledgment budget

This guarantees cross-side validity without ad-hoc exceptions.


===============================================================================
SERIALIZATION AND LOGGING
===============================================================================

Backend send flow:

1) Build or mutate an RPCMessage via helper constructors
2) Serialize using a JSON helper (for example safeJsonDumps):
   - dump model to a plain structure
   - apply deterministic separators and ordering where appropriate
3) Feed the frame into the RPC logging decision engine:
   - decide whether to log based on lane, type, and level
   - emit structured log entries if enabled
4) Transmit the JSON string over the WebSocket


Frontend receive flow:

1) Incoming text frames are parsed as JSON
2) RpcClient validates the basic structure (v, id, type, etc.)
3) Optional logging hooks apply the same filters as the backend
4) RpcClient routes messages by type, lane, and route:
   - control frames update connection and generation state
   - workload frames dispatch to handlers, promises, or subscriptions


This shared schema ensures that any message emitted on one side can be:
- interpreted correctly
- routed deterministically
- logged consistently
- correlated for tracing

No ad-hoc special cases are required.


===============================================================================
END OF IMPLEMENTATION SPECIFICATION 1 - RPC MESSAGE SCHEMA
===============================================================================


--- doc-meta ---
docId: docs/rpc/IS-01_RPC_MESSAGE_SCHEMA.txt
rev: 10
git: 59797b1
----------------
