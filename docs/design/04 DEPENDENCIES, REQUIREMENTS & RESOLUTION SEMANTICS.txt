===============================================================================
DESIGN AREA 4 — GENERIC RESOLUTION SEMANTICS
===============================================================================

Status:
-------
CORE — this area defines the generic, dependency-agnostic resolution
machinery used by Turnix to interpret PackRequests, enumerate candidates,
apply constraints, and produce deterministic outcomes.

This document defines resolution *mechanics only*.

It does NOT define:
- dependency meaning or strength
- savePack behavior
- pinning or copying rules
- activation, execution, or lifecycle semantics

Those are defined by higher-level consumers
(e.g. dependency resolution, save handling, activation).

This area strictly separates:
- request parsing
- candidate enumeration
- constraint application
- deterministic selection
- ambiguity and failure signaling

Nothing in this area implies loading, activation, execution order,
or runtime access.


===============================================================================
1. PURPOSE AND SCOPE
===============================================================================

This design area defines:

- the PackRequest reference grammar
- how PackRequests are parsed and represented
- how candidate packs are enumerated
- how constraints are applied
- how deterministic selection is enforced
- how ambiguity and failure are reported

This area deliberately avoids:
- interpreting *why* a request exists
- deciding whether a request is optional or mandatory
- defining fallback, retry, or recovery behavior

It provides the *mechanical resolution engine*, not the *policy*.


===============================================================================
2. PACK REQUEST REFERENCE GRAMMAR (LOCKED)
===============================================================================

Canonical grammar:

    [<author>@]<packTreeId>[@<semverRequirement>]

Rules:
- case-sensitive
- exactly zero, one, or two '@' characters
- no filesystem paths
- no slashes
- dots are allowed only for hierarchy
- no implicit defaults

Valid examples:
    "ui"
    "ui.controls"
    "Turnix@ui.controls"
    "ui.controls@^2.0"
    "Turnix@ui.controls@~1.4"

Invalid examples:
    "@ui"
    "ui/controls"
    "ui.controls:1.0"


===============================================================================
3. SINGLE '@' DISAMBIGUATION RULE (LOCKED)
===============================================================================

If a PackRequest contains exactly one '@':

- Attempt to parse the suffix as a semantic version requirement
- If parsing succeeds:
    → suffix is treated as semver
- If parsing fails:
    → suffix is treated as author

Examples:
    "foo@1.2"  → packTreeId="foo", semver="1.2"
    "foo@bar"  → author="foo", packTreeId="bar"

Failure to parse semver in this context is NOT an error.
This is an intentional disambiguation rule.


===============================================================================
4. PACKREQUEST INTERNAL REPRESENTATION (LOCKED)
===============================================================================

PackRequest is the parsed, immutable internal representation
used by the resolver.

Structure:

    PackRequest:
        author: str | None
        packTreeId: str
        semverRequirement: SemVerPackRequirement | None
        kind: PackKind | None

Rules:
- created during indexing
- immutable after creation
- carries no policy or resolution state
- kind MAY be injected by the resolution context


===============================================================================
5. RESOLUTION OVERVIEW (LOCKED)
===============================================================================

Resolution is a pure, side-effect-free process.

Inputs:
- a PackRequest
- a snapshot of the PackDescriptorRegistry
- an externally supplied resolution policy context

Outputs:
- exactly one concrete pack identity, OR
- a classified resolution failure

Resolution MUST be deterministic:
Given the same inputs and policy context,
the same outcome MUST always occur.


===============================================================================
6. CANDIDATE ENUMERATION — PHASE A (LOCKED)
===============================================================================

Candidate enumeration identifies packs that are *structurally compatible*
with a PackRequest.

Steps:
1) match packTreeId
2) apply author constraint if present
3) apply kind constraint if present
4) collect remaining candidates

Properties:
- no ordering
- no selection
- no preference evaluation
- no fallback
- no policy interpretation

This phase answers only:

    “Which packs could possibly satisfy this request?”


===============================================================================
7. CONSTRAINT APPLICATION — PHASE B (LOCKED)
===============================================================================

Constraints remove or restrict candidates.

Two constraint classes exist.


-------------------------------------------------------------------------------
7.1 HARD CONSTRAINTS
-------------------------------------------------------------------------------

Hard constraints permanently exclude candidates.

Examples:
- packTreeId mismatch
- required author mismatch
- kind mismatch
- visibility violation
- forbidden root
- savePack scope violation
- concrete version mismatch

Rules:
- candidates failing a hard constraint MUST NOT be selected
- candidates failing a hard constraint MUST NOT be offered to the user
- failure reasons MUST be observable (see DESIGN AREA 12)


-------------------------------------------------------------------------------
7.2 SOFT CONSTRAINTS
-------------------------------------------------------------------------------

Soft constraints discourage selection but do not invalidate structure.

Examples:
- prerelease blocked by policy
- deprecated pack
- policy-based discouragement

Rules:
- soft-constrained candidates remain known
- they are NOT automatically selectable
- selection requires explicit policy or user decision

IMPORTANT:
Soft constraints apply to *candidates*, not to the PackRequest itself.
Whether a request is mandatory or optional is defined externally.
The resolver MUST still order soft-constrained candidates deterministically 
once explicitly allowed.


===============================================================================
8. RESOLUTION SOURCE DETERMINATION (LOCKED)
===============================================================================

Before ordering or selection, the resolver MUST be told
which resolution source applies.

Rules:
- exactly one source applies
- the source is determined externally
- the resolver MUST NOT mix sources
- the resolver MUST NOT fall back between sources

The selected source constrains:
- where candidates are collected from
- which substitution rules are legal


===============================================================================
9. DETERMINISTIC SELECTION (LOCKED)
===============================================================================

After constraints are applied, the resolver MUST:

- impose a total, deterministic ordering on remaining candidates
- select the FIRST candidate in that ordering

Rules:
- ordering MUST be stable and reproducible
- ordering MUST NOT depend on iteration order
- ordering MUST NOT involve randomness

The concrete ordering criteria are defined by
the resolution consumer (e.g. dependency resolution).

Silent substitution is FORBIDDEN.


===============================================================================
10. AMBIGUITY HANDLING (LOCKED)
===============================================================================

If deterministic ordering cannot reduce candidates to a single,
unambiguous choice:

- resolution MUST pause
- ambiguity MUST be explicitly classified
- external input (policy or user) MUST be requested

Once a decision is made:
- it MUST be persisted by the consumer
- future runs MUST be deterministic

The resolver itself MUST NOT guess.
The resolver MUST NOT auto-persist decisions.


===============================================================================
11. FAILURE CONDITIONS (LOCKED)
===============================================================================

Resolution fails if:
- no candidates exist after hard constraints
- no candidates are selectable under policy
- resolution source rules are violated

Failure MUST:
- be explicit
- be classified
- be observable (see DESIGN AREA 12)
- never silently fall back


===============================================================================
12. RESOLUTION ≠ ACTIVATION
===============================================================================

Resolution determines:

    “Which concrete pack identity satisfies this request?”

Resolution does NOT:
- load code
- activate packs
- guarantee execution order
- grant runtime access

Activation and lifecycle behavior are defined elsewhere.


===============================================================================
13. ERROR MODEL (LOCKED)
===============================================================================

Resolution errors include, but are not limited to:
- NotFoundError
- VersionMismatchError
- AmbiguousResolutionError
- PermissionDeniedError

All resolution errors MUST:
- use the standard error envelope
- include PackRequest context
- include resolution source
- include reason classification


===============================================================================
14. LOCKED SUMMARY
===============================================================================

LOCKED:
- PackRequest grammar and disambiguation rules
- two-phase resolution model
- hard vs soft constraint distinction
- concrete version mismatch is a hard exclusion
- deterministic ordering and selection
- no silent substitution
- explicit ambiguity signaling

DEFERRED:
- dependency semantics
- savePack behavior
- pinning and copying rules
- activation and lifecycle behavior

Those are defined by higher-level design areas.


===============================================================================
END OF DESIGN AREA 4
===============================================================================

--- doc-meta ---
docId: docs/design/04 DEPENDENCIES, REQUIREMENTS & RESOLUTION SEMANTICS.txt
rev: 4
git: d1b3b4b
---------------
