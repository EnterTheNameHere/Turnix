===============================================================================
DESIGN AREA 10 — FILE I/O, READERS / WRITERS & PERSISTENCE SAFETY
===============================================================================

Status:
-------
CORE — this area defines how data is read and written, who is allowed
to do so, and how failures are handled without corrupting identity,
history, or user trust.

This area is NON-NEGOTIABLE.
All persistence in Turnix is centralized and mediated.


===============================================================================
1. CORE PRINCIPLE (LOCKED)
===============================================================================

ALL file reading and writing in Turnix MUST go through a centralized
I/O authority.

No pack, tool, or runtime component may read or write persistent data
by accessing the filesystem directly.

This applies to:
- configuration
- manifests
- savePacks
- logs and traces
- caches
- compiled assets
- future databases or storage backends


===============================================================================
2. CENTRAL AUTHORITY: IoManager (LOCKED)
===============================================================================

Component:
    IoManager

IoManager is the sole authority responsible for persistence.

Responsibilities:
- mediate all reads and writes
- enforce root boundaries and permissions
- normalize and validate paths
- select appropriate readers / writers
- classify errors
- emit trace reasons
- provide atomic write guarantees
- manage backups and snapshots per policy
- ensure rollback points for identity-bearing changes

No other component may bypass IoManager.


===============================================================================
3. READERS & WRITERS (LOCKED CONCEPT)
===============================================================================

IoManager does not hardcode all file formats.

Instead, it delegates actual data handling to registered providers:

- Readers  → load data from storage
- Writers  → persist data to storage

Each Reader / Writer:
- supports one or more specific kinds
- declares its supported formats
- is registered with IoManager
- operates strictly within IoManager control
- executes in the Turnix-controlled backend environment (never in frontend)


===============================================================================
4. RAW ACCESS BOUNDARY (LOCKED)
===============================================================================

Reader / Writer implementations MAY internally use:
- raw filesystem handles
- platform-native APIs
- low-level I/O operations

However:

LOCKED:
- raw handles MUST NOT escape the Reader / Writer boundary
- raw paths MUST NOT be exposed to calling code
- packs NEVER receive filesystem handles or unrestricted path APIs

Readers return fully loaded data.
Writers accept data to persist.

The raw filesystem is an internal implementation detail of IoManager
and its providers, never part of the public runtime surface.


===============================================================================
5. BUILT-IN READERS / WRITERS (LOCKED)
===============================================================================

Turnix core provides the following built-in kinds:

- utf8Text
- binary
- json
- json5
- jsonl

These are ALWAYS available before discovery begins.


===============================================================================
6. EXTENDED READERS / WRITERS (LOCKED POLICY)
===============================================================================

Additional formats (e.g. YAML, SQLite, embeddings):

- MUST be provided by packs
- MUST register as I/O providers with IoManager
- MUST be activated BEFORE use
- MUST declare supported kinds explicitly

Pack-provided Readers and Writers MUST NOT be usable unless the
providing pack is activated.

Turnix MUST NOT attempt to auto-discover or load providers mid-read.


===============================================================================
7. DISCOVERY- AND INDEXING-TIME I/O LIMITS (LOCKED)
===============================================================================

During discovery and indexing:

Allowed:
- built-in readers only

Disallowed:
- pack-provided readers
- pack-provided writers
- compilers
- transformers
- streaming

Rationale:
Early phases must be deterministic, fast, and independent of packs.


===============================================================================
8. WRITE PERMISSIONS (LOCKED)
===============================================================================

Writable roots at runtime:
- userdata/
- saves/

Read-only roots at runtime:
- custom/
- first-party/
- third-party/

Authoring tools MAY override these rules OUTSIDE runtime orchestration.
Runtime orchestration MUST enforce them strictly.

IoManager enforces these rules strictly.


===============================================================================
9. ERROR CLASSIFICATION (LOCKED)
===============================================================================

All I/O errors are classified into exactly one category:

A) UNRECOVERABLE (Fatal)
    - failure to load required config schema
    - failure to load default configuration
    - corruption of identity-bearing state required
      before minimal UI is available

→ ReactorScramError

B) USER-DECIDABLE
    - corrupted userdata config
    - missing optional files
    - version mismatch requiring migration or reset

→ execution pauses, UI decision required

C) OPTIONAL / BEST-EFFORT
    - logs
    - traces
    - caches

→ warning only

No silent fallback is allowed for identity-bearing data.


===============================================================================
10. ERROR PRESENTATION & BOOTSTRAP GUARANTEE (LOCKED)
===============================================================================

User recovery MUST be UI-mediated.

Minimum guaranteed runtime before any user decision:
- FastAPI running
- index.html served
- bootstrap.js loaded
- rpc.js available
- error overlay functional

Before this point:
- all errors are fatal
- no recovery is possible


===============================================================================
11. TRACE REASONS (LOCKED NAMING)
===============================================================================

Refused, skipped, or failed I/O MUST emit trace reasons.

Trace reasons:
- use PascalCase
- are non-user-facing by default
- are stable identifiers

Examples:
- ManifestInRootLayerDir
- SymlinkForbidden
- FileAccessDenied
- ScanDepthLimitReached

Trace naming is kept here until tracing is centralized (DA-12).


===============================================================================
12. SAVE FILE HANDLING (LOCKED)
===============================================================================

SavePacks:
- discovered via saves/*/*/manifest.json5
- shallow-scanned by default
- internal copied packs NOT indexed initially

Deep scanning occurs ONLY when:
- a save is explicitly loaded
- PackManager inspects the save
- configuration explicitly enables deep scanning

Visibility of copied packs is strictly save-local.


===============================================================================
13. CONFIG LOADING ORDER (LOCKED)
===============================================================================

Configuration is loaded in this order:

1) config schemas
2) default configuration
3) userdata configuration
4) validation
5) indexing decisions

Failure in steps 1–2 → fatal.
Failure in step 3 → user-decidable.


===============================================================================
14. MIGRATORS & ROLLBACK GUARANTEES (LOCKED)
===============================================================================

Supported migrators:
- ConfigMigrator
- ManifestMigrator
- future migrator types

Rules:
- migrators are versioned
- applied sequentially toward target version
- deterministic and side-effect controlled

IMPORTANT:
- Migrators do NOT implement inverse operations.
- BEFORE any identity-bearing mutation is committed:
    → IoManager MUST create a rollback point
      (backup or snapshot, per policy)

Identity-bearing mutations include, but are not limited to:
- configuration migrations
- savePack structure changes
- PackManager-driven save edits
- any multi-file write that must remain internally consistent

Rollback is provided by IoManager, not by migrators themselves.


===============================================================================
15. BACKUPS & SNAPSHOTS (LOCKED CONCEPT)
===============================================================================

IoManager supports two durability mechanisms:

A) File backups (single-file)
    - previous versions may be retained
    - used for configs, manifests, small critical files

B) Snapshots (multi-file atomic units)
    - group logically related files
    - created explicitly
    - restored only by user-visible actions

Policy controls:
- retention
- storage location
- cleanup behavior

No automatic rollback without policy or user consent.


===============================================================================
16. STREAMING READERS / WRITERS (PLANNED, PARTIALLY LOCKED)
===============================================================================

Streaming is an explicit I/O mode for large or long-lived operations.

Streaming read:
- returns an async iterator / stream

Streaming write:
- accepts a stream and stages output incrementally

Core rules (LOCKED):
- streaming is NEVER implicit
- caller MUST request streaming explicitly
- staging is mandatory
- cancellation MUST be safe


-------------------------------------------------------------------------------
16.1 STREAMING KINDS (LOCKED)
-------------------------------------------------------------------------------

Examples:
- utf8TextStream
- binaryStream
- jsonlStream
- tarStream                  (future)
- saveSnapshotStream         (future)

Non-streaming kinds remain non-streaming.


-------------------------------------------------------------------------------
16.2 CANCELLATION & CLEANUP (LOCKED)
-------------------------------------------------------------------------------

Streaming read:
- cancellation closes handles
- no persistence side effects

Streaming write:
- cancellation MUST NOT produce partial valid output
- final destination is updated ONLY on commit

Staging artifacts:
- must be garbage-collectable
- SHOULD be tracked for cleanup on restart


-------------------------------------------------------------------------------
16.3 WHERE STREAMING IS FORBIDDEN (LOCKED)
-------------------------------------------------------------------------------

Streaming MUST NOT be used for:
- discovery
- indexing
- manifest loading
- config schema loading
- default configuration loading
- userdata configuration loading
- dependency resolution
- activation-critical reads

These phases require full determinism.


===============================================================================
17. RECOVERY USING BACKUPS (LOCKED)
===============================================================================

When user-decidable data fails to load:

IoManager MAY offer:
- restore last known good
- reset to defaults
- quarantine broken data
- proceed without (only if policy allows)

All recovery actions are UI-mediated.


===============================================================================
18. NO BACKDOORS (LOCKED)
===============================================================================

Packs:
- cannot bypass IoManager
- cannot access arbitrary paths
- cannot intercept core I/O

All persistence authority is centralized.


===============================================================================
19. OPEN QUESTIONS
===============================================================================

OPEN:
- streaming backpressure API
- resumable streaming
- verification hooks (hashing, limits)
- encrypted storage backends


===============================================================================
20. LOCKED SUMMARY
===============================================================================

LOCKED:
- centralized IoManager
- Reader / Writer abstraction
- controlled raw access boundary
- strict root permissions
- rollback points before identity-bearing mutations
- UI-mediated recovery
- deterministic early phases
- no silent fallback

OPEN:
- performance optimizations
- future storage backends


===============================================================================
END OF DESIGN AREA 10
===============================================================================

--- doc-meta ---
docId: docs/design/10 FILE IO, READERS, WRITERS & PERSISTENCE SAFETY.txt
rev: 6
git: d1b3b4b
---------------
