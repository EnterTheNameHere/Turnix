======================================================================
DESIGN AREA 10 — FILE I/O, READERS/WRITERS & PERSISTENCE SAFETY
======================================================================

Status:
-------
CORE — this area defines *how data is read and written*, *who is allowed
to do it*, and *how failures are handled* without corrupting identity or
state.

This area is NON-NEGOTIABLE.
All persistence goes through Turnix.


----------------------------------------------------------------------
1. CORE PRINCIPLE (LOCKED)
----------------------------------------------------------------------

ALL file reading and writing in Turnix MUST go through
a centralized I/O system.

No direct filesystem access is allowed outside it.

This applies to:
- config
- manifests
- saves
- logs
- caches
- compiled assets
- future databases or stores


----------------------------------------------------------------------
2. CENTRAL COMPONENT (LOCKED)
----------------------------------------------------------------------

Component name:
    IoManager

Responsibilities:
- mediate all reads and writes
- enforce root boundaries
- enforce read/write permissions
- normalize paths
- classify errors
- produce standard error envelopes
- emit trace reasons
- provide atomic write guarantees
- manage backups/snapshots per policy


----------------------------------------------------------------------
3. READERS & WRITERS (LOCKED CONCEPT)
----------------------------------------------------------------------

IoManager does not hardcode all formats.

Instead it uses:
- Readers  → load data
- Writers  → persist data

Each reader/writer:
- handles a specific kind
- declares capabilities
- is registered with IoManager


----------------------------------------------------------------------
4. BUILT-IN READERS / WRITERS (LOCKED)
----------------------------------------------------------------------

Provided by Turnix core:
- utf8Text
- binary
- json
- json5
- jsonl

These are ALWAYS available before discovery.


----------------------------------------------------------------------
5. EXTENDED READERS / WRITERS (LOCKED POLICY)
----------------------------------------------------------------------

Anything beyond built-ins (e.g. YAML, SQLite, embeddings):

- must be provided by a pack
- must register as an I/O provider
- must be activated BEFORE use
- must declare supported formats

Turnix will NOT attempt to auto-discover readers mid-read.


----------------------------------------------------------------------
6. DISCOVERY-TIME I/O LIMITS (LOCKED)
----------------------------------------------------------------------

During discovery:

Allowed:
- built-in readers only

Disallowed:
- pack-provided readers
- compilers
- transformers

Rationale:
Discovery must be deterministic and independent of packs.


----------------------------------------------------------------------
7. WRITE PERMISSIONS (LOCKED)
----------------------------------------------------------------------

Writable locations:
- userdata/
- saves/

Read-only locations during runtime:
- first-party/
- third-party/
- custom/

Authoring tools may override this OUTSIDE runtime.


----------------------------------------------------------------------
8. ERROR CLASSES (LOCKED)
----------------------------------------------------------------------

I/O errors are classified as:

A) Unrecoverable (fatal)
    - cannot load config schema
    - cannot load default config
    - corrupted required state before minimal UI is ready

→ ReactorScramError

B) User-decidable
    - corrupted userdata config
    - missing optional file that the user may choose to recreate
    - version mismatch requiring migration/reset/choice

→ Pausable error with UI decision

C) Optional / best-effort
    - logs
    - traces
    - caches

→ Warning only


----------------------------------------------------------------------
9. ERROR PRESENTATION (LOCKED)
----------------------------------------------------------------------

Console / terminal interaction is NOT relied upon.

User decisions MUST be shown via UI:
- Electron frontend
- minimal error UI
- dialog / overlay

Execution may pause waiting for user input.


----------------------------------------------------------------------
10. BOOTSTRAP GUARANTEE (LOCKED)
----------------------------------------------------------------------

Minimum runtime required before ANY user decision UI:

- FastAPI running
- index.html served
- bootstrap.js loaded
- rpc.js available
- error overlay capable of rendering

Before this point:
- any error is fatal
- no user recovery possible


----------------------------------------------------------------------
11. TRACE REASONS (LOCKED NAMING)
----------------------------------------------------------------------

Refused or skipped I/O MUST emit trace reasons, e.g.:

- ManifestInRootLayerDir
- SymlinkForbidden
- FileAccessDenied
- ScanDepthLimitReached

Reasons use PascalCase.


----------------------------------------------------------------------
12. SAVE FILE HANDLING (LOCKED)
----------------------------------------------------------------------

SavePacks:
- discovered by saves/*/*/manifest.json5
- NOT deep-scanned by default
- internal packs scanned only when:
    - save is loaded
    - PackManager inspects save
    - config explicitly enables deep scan


----------------------------------------------------------------------
13. CONFIG LOADING ORDER (LOCKED)
----------------------------------------------------------------------

Order:
1) config schemas
2) default config
3) userdata config
4) validation
5) indexing decisions

If step 1 or 2 fails → fatal.
Step 3 may be user-recoverable.


----------------------------------------------------------------------
14. MIGRATORS (LOCKED CONCEPT)
----------------------------------------------------------------------

Supported:
- ConfigMigrator
- ManifestMigrator
- Future *Migrator

Rules:
- migrators are versioned
- applied sequentially
- no rollback
- migrations are deterministic


----------------------------------------------------------------------
15. BACKUPS & SNAPSHOTS (LOCKED CONCEPT)
----------------------------------------------------------------------

Turnix supports generic backup/snapshot creation via IoManager.

Purpose:
- provide a "last known good" rollback point when corruption is detected
- support multi-file consistency (savePack style backups)
- support safe upgrades and migrations

Definitions:

A) File backup (single-file)
    - IoManager may keep a previous version of a file (or multiple versions)
    - used for configs, manifests, small critical documents

B) Snapshot (multi-file / atomic unit)
    - a snapshot groups multiple files that belong together logically
      (example: savePack state, memory layers, save-bound config, indices)
    - snapshot creation is an explicit IoManager operation

Policy-driven behavior:
- whether backups are kept, how many, and where they live is configurable
- rollback is never automatic without a clear policy or user decision
- restoring from backup/snapshot is a user-visible action when it changes state


----------------------------------------------------------------------
16. RECOVERY USING BACKUPS (LOCKED POLICY)
----------------------------------------------------------------------

If reading/parsing fails for user-decidable data, IoManager may:
- detect the presence of a backup/snapshot
- offer UI options, e.g.:
    - restore last known good
    - reset to defaults
    - open/quarantine the broken file
    - proceed without (only if explicitly allowed by policy)

No silent fallback is allowed for configuration or other identity-bearing state.


----------------------------------------------------------------------
17. NO BACKDOORS (LOCKED)
----------------------------------------------------------------------

Packs:
- cannot bypass IoManager
- cannot write arbitrary paths
- cannot intercept core I/O

All persistence is centralized.


----------------------------------------------------------------------
18. OPEN QUESTIONS
----------------------------------------------------------------------

OPEN:
- streaming readers
- transactional multi-file writes (implementation details)
- snapshot vs incremental save strategy
- encrypted stores


----------------------------------------------------------------------
19. LOCKED SUMMARY
----------------------------------------------------------------------

LOCKED:
- centralized IoManager
- reader/writer abstraction
- strict permission model
- fatal vs recoverable error split
- UI-mediated recovery
- no discovery-time extensions
- generic backups and multi-file snapshots via IoManager
- no silent fallback for identity-bearing data

OPEN:
- performance optimizations
- future storage backends


----------------------------------------------------------------------
END OF DESIGN AREA 10
----------------------------------------------------------------------

