======================================================================
DESIGN AREA 10 — FILE I/O, READERS/WRITERS & PERSISTENCE SAFETY
======================================================================

Status:
-------
CORE — this area defines *how data is read and written*, *who is allowed
to do it*, and *how failures are handled* without corrupting identity or
state.

This area is NON-NEGOTIABLE.
All persistence goes through Turnix.


----------------------------------------------------------------------
1. CORE PRINCIPLE (LOCKED)
----------------------------------------------------------------------

ALL file reading and writing in Turnix MUST go through
a centralized I/O system.

No direct filesystem access is allowed outside it.

This applies to:
- config
- manifests
- saves
- logs
- caches
- compiled assets
- future databases or stores


----------------------------------------------------------------------
2. CENTRAL COMPONENT (LOCKED)
----------------------------------------------------------------------

Component name:
    IoManager

Responsibilities:
- mediate all reads and writes
- enforce root boundaries
- enforce read/write permissions
- normalize paths
- classify errors
- produce standard error envelopes
- emit trace reasons
- provide atomic write guarantees
- manage backups/snapshots per policy


----------------------------------------------------------------------
3. READERS & WRITERS (LOCKED CONCEPT)
----------------------------------------------------------------------

IoManager does not hardcode all formats.

Instead it uses:
- Readers  → load data
- Writers  → persist data

Each reader/writer:
- handles a specific kind
- declares capabilities
- is registered with IoManager


----------------------------------------------------------------------
4. BUILT-IN READERS / WRITERS (LOCKED)
----------------------------------------------------------------------

Provided by Turnix core:
- utf8Text
- binary
- json
- json5
- jsonl

These are ALWAYS available before discovery.


----------------------------------------------------------------------
5. EXTENDED READERS / WRITERS (LOCKED POLICY)
----------------------------------------------------------------------

Anything beyond built-ins (e.g. YAML, SQLite, embeddings):

- must be provided by a pack
- must register as an I/O provider
- must be activated BEFORE use
- must declare supported formats

Turnix will NOT attempt to auto-discover readers mid-read.


----------------------------------------------------------------------
6. DISCOVERY-TIME I/O LIMITS (LOCKED)
----------------------------------------------------------------------

During discovery:

Allowed:
- built-in readers only

Disallowed:
- pack-provided readers
- compilers
- transformers

Rationale:
Discovery must be deterministic and independent of packs.


----------------------------------------------------------------------
7. WRITE PERMISSIONS (LOCKED)
----------------------------------------------------------------------

Writable locations:
- userdata/
- saves/

Read-only locations during runtime:
- first-party/
- third-party/
- custom/

Authoring tools may override this OUTSIDE runtime.


----------------------------------------------------------------------
8. ERROR CLASSES (LOCKED)
----------------------------------------------------------------------

I/O errors are classified as:

A) Unrecoverable (fatal)
    - cannot load config schema
    - cannot load default config
    - corrupted required state before minimal UI is ready

→ ReactorScramError

B) User-decidable
    - corrupted userdata config
    - missing optional file that the user may choose to recreate
    - version mismatch requiring migration/reset/choice

→ Pausable error with UI decision

C) Optional / best-effort
    - logs
    - traces
    - caches

→ Warning only


----------------------------------------------------------------------
9. ERROR PRESENTATION (LOCKED)
----------------------------------------------------------------------

Console / terminal interaction is NOT relied upon.

User decisions MUST be shown via UI:
- Electron frontend
- minimal error UI
- dialog / overlay

Execution may pause waiting for user input.


----------------------------------------------------------------------
10. BOOTSTRAP GUARANTEE (LOCKED)
----------------------------------------------------------------------

Minimum runtime required before ANY user decision UI:

- FastAPI running
- index.html served
- bootstrap.js loaded
- rpc.js available
- error overlay capable of rendering

Before this point:
- any error is fatal
- no user recovery possible


----------------------------------------------------------------------
11. TRACE REASONS (LOCKED NAMING)
----------------------------------------------------------------------

Refused or skipped I/O MUST emit trace reasons, e.g.:

- ManifestInRootLayerDir
- SymlinkForbidden
- FileAccessDenied
- ScanDepthLimitReached

Reasons use PascalCase.


----------------------------------------------------------------------
12. SAVE FILE HANDLING (LOCKED)
----------------------------------------------------------------------

SavePacks:
- discovered by saves/*/*/manifest.json5
- NOT deep-scanned by default
- internal packs scanned only when:
    - save is loaded
    - PackManager inspects save
    - config explicitly enables deep scan


----------------------------------------------------------------------
13. CONFIG LOADING ORDER (LOCKED)
----------------------------------------------------------------------

Order:
1) config schemas
2) default config
3) userdata config
4) validation
5) indexing decisions

If step 1 or 2 fails → fatal.
Step 3 may be user-recoverable.


----------------------------------------------------------------------
14. MIGRATORS (LOCKED CONCEPT)
----------------------------------------------------------------------

Supported:
- ConfigMigrator
- ManifestMigrator
- Future *Migrator

Rules:
- migrators are versioned
- applied sequentially
- no rollback
- migrations are deterministic


----------------------------------------------------------------------
15. BACKUPS & SNAPSHOTS (LOCKED CONCEPT)
----------------------------------------------------------------------

Turnix supports generic backup/snapshot creation via IoManager.

Purpose:
- provide a "last known good" rollback point when corruption is detected
- support multi-file consistency (savePack style backups)
- support safe upgrades and migrations

Definitions:

A) File backup (single-file)
    - IoManager may keep a previous version of a file (or multiple versions)
    - used for configs, manifests, small critical documents

B) Snapshot (multi-file / atomic unit)
    - a snapshot groups multiple files that belong together logically
      (example: savePack state, memory layers, save-bound config, indices)
    - snapshot creation is an explicit IoManager operation

Policy-driven behavior:
- whether backups are kept, how many, and where they live is configurable
- rollback is never automatic without a clear policy or user decision
- restoring from backup/snapshot is a user-visible action when it changes state


----------------------------------------------------------------------
16. STREAMING READERS / WRITERS (PLANNED SUPPORT)
----------------------------------------------------------------------

Status:
    PLANNED — supported when Turnix needs it for large data and long-lived
    I/O (traces, large assets, save snapshots, bulk exports).
    This is NOT required for initial Turnix functionality.

Rationale:
    Streaming reduces memory pressure and latency for large payloads, and it
    enables "progressive" production/consumption without forcing a full
    materialization of data in memory.

Core rule:
    Streaming is an explicit I/O mode.
    It is NEVER implicit.

    A caller MUST request streaming explicitly (by kind / API),
    and IoManager MUST enforce streaming-specific guarantees.

----------------------------------------------------------------------
16.1 WHAT "STREAMING" MEANS IN TURNIX (LOCKED)
----------------------------------------------------------------------

Streaming read:
    IoManager returns an async iterator / stream of chunks or records.

Streaming write:
    IoManager accepts an async iterator / stream of chunks or records,
    and persists them incrementally into a staged destination.

Important:
    Streaming changes *how* data is transferred, not *what* data means.
    A streamed file still has a final logical representation.

----------------------------------------------------------------------
16.2 STREAMING KINDS (LOCKED)
----------------------------------------------------------------------

Streaming is only allowed for dedicated streaming kinds, e.g.:

    - utf8TextStream     (chunked text)
    - binaryStream       (chunked bytes)
    - jsonlStream        (record stream)
    - tarStream          (archived file stream)          [future]
    - saveSnapshotStream (multi-file streamed commit)    [future]

Non-streaming kinds remain non-streaming, e.g.:
    - json
    - json5
    - manifest.json5
    - config.json5

No implicit streaming fallback is allowed.

----------------------------------------------------------------------
16.3 CANCELLATION & CLEANUP GUARANTEES (LOCKED)
----------------------------------------------------------------------

Streaming read cancellation:
    - Cancellation MUST be safe.
    - IoManager MUST close underlying handles promptly.
    - No partial state is committed to persistence by reads.

Streaming write cancellation:
    - Cancellation MUST NOT produce a partially "valid" final file.
    - IoManager MUST ensure one of:
        A) no final destination exists (staging only), OR
        B) destination remains at last known good version (transactional).

Cleanup rules:
    - All streaming writes are staged into temp locations.
    - Staging artifacts MUST be garbage-collectable by IoManager.
    - IoManager SHOULD track staged artifacts for cleanup on restart.

----------------------------------------------------------------------
16.4 WHERE STREAMING IS FORBIDDEN (LOCKED)
----------------------------------------------------------------------

Streaming MUST NOT be used for:

    - discovery-time reading
    - indexing-time canonicalization and identity-critical parsing
    - activation-critical reads required to build a deterministic pack graph
    - configuration schema loading
    - default configuration loading
    - manifest loading used for pack identity or dependency resolution

Rationale:
    These phases must be deterministic, fully validated, and must not
    introduce partial/interleaved states or time-dependent outcomes.

----------------------------------------------------------------------
16.5 WHERE STREAMING IS EXPECTED TO BE USED (PLANNED)
----------------------------------------------------------------------

Streaming is intended for post-indexing runtime workflows, such as:

    - trace/log streaming to UI
    - large asset delivery to browser
    - bulk export/import (packs, saves, caches)
    - save snapshot creation (multi-file streamed commit)
    - large dataset reads for tooling (e.g., embeddings, indexes)

Rule of thumb:
    Streaming is appropriate when the caller naturally awaits data and no
    other part of the system is blocked waiting for this read/write to
    complete in order to preserve identity or determinism.

----------------------------------------------------------------------
16.6 SAVE SNAPSHOT AS A MULTI-FILE "STREAMED COMMIT" (PLANNED)
----------------------------------------------------------------------

Goal:
    Provide an optional durability mechanism for SavePack snapshots where
    multiple files must be updated together as one logical transaction.

High-level contract:
    - A snapshot write is staged into a new snapshot directory (or archive).
    - The snapshot is considered valid only once a commit marker exists.
    - Activation/restore uses only committed snapshots.
    - If staging fails or is cancelled:
        - the previous committed snapshot remains valid
        - staged artifacts are cleaned up (immediately or on restart)

Commit semantics:
    - IoManager defines a "commit point" as an atomic rename / replace of the
      snapshot root, OR a commit marker file written last after all parts are
      flushed and verified.

Backup integration:
    - IoManager MAY keep a bounded number of previous committed snapshots
      (or move the old snapshot into a backup namespace) based on policy.

----------------------------------------------------------------------
16.7 ERROR CLASSIFICATION FOR STREAMING (LOCKED)
----------------------------------------------------------------------

Streaming errors MUST be classified using the same rules as all I/O:

    - Unrecoverable (fatal) for identity-bearing streaming commits
    - User-decidable for optional repairs (e.g., discard staged snapshot)
    - Optional/best-effort for traces/logs/caches

User decisions (if required) remain UI-mediated.

----------------------------------------------------------------------
END 16. STREAMING READERS / WRITERS
----------------------------------------------------------------------

OPEN QUESTIONS (kept open, but streaming itself is planned):
    - streaming backpressure API shape (chunk size, pacing)
    - resumable streaming (continuation tokens)
    - verification hooks (hashing, size limits)
    - policy for staged artifact cleanup on crash


----------------------------------------------------------------------
17. RECOVERY USING BACKUPS (LOCKED POLICY)
----------------------------------------------------------------------

If reading/parsing fails for user-decidable data, IoManager may:
- detect the presence of a backup/snapshot
- offer UI options, e.g.:
    - restore last known good
    - reset to defaults
    - open/quarantine the broken file
    - proceed without (only if explicitly allowed by policy)

No silent fallback is allowed for configuration or other identity-bearing state.


----------------------------------------------------------------------
18. NO BACKDOORS (LOCKED)
----------------------------------------------------------------------

Packs:
- cannot bypass IoManager
- cannot write arbitrary paths
- cannot intercept core I/O

All persistence is centralized.


----------------------------------------------------------------------
19. OPEN QUESTIONS
----------------------------------------------------------------------

OPEN:
- transactional multi-file writes (implementation details)
- snapshot vs incremental save strategy
- encrypted stores


----------------------------------------------------------------------
20. LOCKED SUMMARY
----------------------------------------------------------------------

LOCKED:
- centralized IoManager
- reader/writer abstraction
- strict permission model
- fatal vs recoverable error split
- UI-mediated recovery
- no discovery-time extensions
- generic backups and multi-file snapshots via IoManager
- no silent fallback for identity-bearing data

OPEN:
- performance optimizations
- future storage backends


----------------------------------------------------------------------
END OF DESIGN AREA 10
----------------------------------------------------------------------

