===============================================================================
DESIGN AREA 12 — TRACING, DIAGNOSTICS & OBSERVABILITY
===============================================================================

Status:
-------
CORE — this area defines *how Turnix observes itself*, *how decisions are
explained*, and *how failures can be reconstructed after the fact*.

Tracing is not logging.
Tracing is structural truth.


===============================================================================
1. CORE CONCEPT
===============================================================================

Tracing answers:

    “What happened, in what order, and why?”

It must support:
- debugging
- user explanation
- post-mortem analysis
- reproducibility

Tracing is authoritative.
If it is not traced, it did not happen.


===============================================================================
2. TRACE FIRST, LOG SECOND (LOCKED)
===============================================================================

Turnix prioritizes:
- structured trace events
- explicit reasons
- causal relationships

Plain logs are secondary and optional.
Logs MUST NOT be relied upon for correctness or explanation.


===============================================================================
3. TRACE EVENT MODEL (LOCKED)
===============================================================================

Each trace event has:

- eventId
- timestamp
- level (info | warn | error | fatal)
- domain (discovery, resolution, activation, io, config, capability, debugger, etc.)
- message (human-readable)
- reason (PascalCase enum)
- attributes (structured key-value data)
- optional parentEventId

Events form a DAG, not a flat stream.

Causality MUST be preserved across subsystems.
Temporal ordering MUST NOT be relied upon to infer causality.


===============================================================================
4. TRACE REASONS (LOCKED)
===============================================================================

Reasons are:
- stable identifiers
- PascalCase
- machine-parseable
- semantically precise

Examples:
- ManifestInRootLayerDir
- SymlinkForbidden
- ScanDepthLimitReached
- PermissionDenied
- NotActivated
- SemVerParseError
- ConfigValueOverridden
- ConfigValueComputed
- ConfigWriteBlocked
- RestoreFromBackupChosen

Debugger-related examples (NON-EXHAUSTIVE):
- DebuggerInspection
- DebuggerMutationRequested
- DebuggerMutationApplied
- DebuggerMutationStaged
- DebuggerMutationDiscarded
- ManualPauseRequested
- ManualPauseGranted
- ManualPauseRefused
- JobPausedAtSafePoint
- JobPauseDeferred
- JobAbortRequested

Reasons MUST be emitted whenever:
- a decision is made
- a value source changes
- a write is accepted or refused
- behavior differs from defaults
- debugger tooling inspects or mutates state
- execution is paused, staged, resumed, or aborted via debugging facilities


===============================================================================
5. TRACE DURING DISCOVERY (LOCKED)
===============================================================================

Discovery emits trace events for:
- manifest found
- manifest skipped
- manifest rejected
- depth limit reached
- symlink refusal

No silent skipping allowed.
Each ignored artifact MUST have a reason.


===============================================================================
6. TRACE DURING RESOLUTION (LOCKED)
===============================================================================

Resolution emits:
- candidate sets
- filters applied
- soft vs hard rejections
- scoring results
- ambiguity detection
- user decision points

Resolution traces must be sufficient to:
- replay logic offline
- explain “why this pack/version was chosen”
- explain “why another was not”


===============================================================================
7. TRACE DURING ACTIVATION (LOCKED)
===============================================================================

Activation emits:
- activation start
- dependency activation ordering
- entrypoint invocation
- service registration
- capability registration
- activation failure or success

Activation traces define runtime causality and scope boundaries.


===============================================================================
8. CAPABILITY CALL TRACING (LOCKED)
===============================================================================

Every capability call emits:
- caller pack identity
- target capability identifier
- permission classification
- permission decision
- execution outcome
- duration

Capability traces MUST distinguish:
- denied execution
- deferred execution (waiting on UI)
- successful execution

This is mandatory for trust and audit.


===============================================================================
9. CONFIG & STATE TRACE INTEGRATION (LOCKED)
===============================================================================

Configuration and state interactions MUST be traced distinctly.

Trace MUST differentiate between:

A) Stored mutation
   - change written via IoManager
   - persisted to userdata or savePack
   - attributed to scope (engine / pack-global / save)

B) Computed effect
   - derived value
   - reactive transform
   - accessibility scaling
   - runtime-only override

C) Read resolution
   - which layer provided the value
   - defaults vs user override vs save override

Debugger-initiated state changes MUST be explicitly labeled as such
and MUST NOT be conflated with runtime or pack-originated mutations.

Computed effects MUST NOT appear as stored mutations.

Trace attributes MUST include:
- config key or state key
- scope (engine | pack-global | save | runtime)
- source layer
- pack identity (if applicable)
- debuggerInitiated: true | false


===============================================================================
10. TRACE STORAGE (LOCKED POLICY)
===============================================================================

Trace data is:
- best-effort persistence
- non-blocking
- bounded / rotating
- safe to drop under pressure

Failure to write traces:
- MUST be traced
- MUST NOT block execution

Trace loss is acceptable; silent behavior is not.


===============================================================================
11. TRACE ACCESS (LOCKED)
===============================================================================

Trace access via:
- TraceMonitor UI
- backend APIs
- future export formats

No direct file scraping.
Trace consumers MUST rely on structured access.


===============================================================================
12. USER-FACING DIAGNOSTICS (LOCKED)
===============================================================================

Trace events may be surfaced to users as:
- warnings
- explanations
- decision prompts
- error dialogs
- debugger inspection views

User-facing views MUST:
- simplify presentation
- preserve causality
- never fabricate reasons

Raw trace remains developer-facing.


===============================================================================
13. ERROR ENVELOPE INTEGRATION (LOCKED)
===============================================================================

All errors include:
- error code
- human message
- reason
- trace correlation identifiers

Errors and traces are inseparable.
Every surfaced error MUST map to trace events.


===============================================================================
14. DEV-MODE ENHANCEMENTS (LOCKED)
===============================================================================

Development mode MAY add:
- verbose traces
- speculative branches
- “why not chosen” explanations
- layer-resolution breakdowns
- debugger-specific annotations

Dev-mode enhancements:
- are explicit
- are never enabled silently
- MUST NOT change behavior


===============================================================================
15. NO HEURISTIC SUPPRESSION (LOCKED)
===============================================================================

Turnix MUST NOT:
- suppress “obvious” traces
- collapse distinct decisions
- infer reasons without recording them
- merge computed effects with stored changes
- hide debugger-originated actions

Explicit beats clever.


===============================================================================
16. OPEN QUESTIONS
===============================================================================

OPEN:
- trace visualization schemas
- time-travel replay tooling
- cross-session trace stitching
- diff-oriented trace views


===============================================================================
17. LOCKED SUMMARY
===============================================================================

LOCKED:
- structured tracing everywhere
- stable PascalCase reasons
- causal DAG model
- full discovery/resolution/activation coverage
- capability auditing
- config vs computed distinction
- debugger inspection and mutation traceability
- scope-aware tracing

OPEN:
- visualization & tooling only


===============================================================================
END OF DESIGN AREA 12
===============================================================================

--- doc-meta ---
docId: docs/design/12 TRACING, DIAGNOSTICS & OBSERVABILITY.txt
rev: 5
git: f238edf
---------------
