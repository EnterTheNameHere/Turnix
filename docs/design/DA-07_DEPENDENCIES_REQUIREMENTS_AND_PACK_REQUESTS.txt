===============================================================================
DESIGN AREA 7 - DEPENDENCIES, REQUIREMENTS & PACK REQUESTS
===============================================================================

Status:
-------
CORE - this area defines how packs declare hard requirements, how those
requirements are resolved deterministically, and how resolution outcomes
are enforced without silent substitution.

This area is authoritative for:
- dependency declaration semantics
- PackRequest meaning in dependency context
- resolution source selection
- deterministic selection policy
- saved, pinned, and global pack behavior
- ambiguity handling and required user involvement

Generic resolution mechanics are defined in DESIGN AREA 4.
Observability and tracing are defined in DESIGN AREA 12.


===============================================================================
1. CORE CONCEPT
===============================================================================

A dependency expresses a hard functional requirement.

Meaning:
    "This pack cannot function correctly unless another pack exists
     that satisfies this request."

Dependencies are CONTRACTS, not preferences.

Declaring a dependency:
- does NOT load code
- does NOT activate a pack
- does NOT grant visibility
- does NOT grant capabilities
- does NOT define activation order

Failure to satisfy a dependency is a HARD FAILURE unless explicitly
resolved through user or policy intervention.


===============================================================================
2. DECLARING DEPENDENCIES (MANIFEST LEVEL)
===============================================================================

Manifest field:
    packs

Type:
    PackRequestRef | list[PackRequestRef]

Examples:
    "packs": ["ui.controls"]
    "packs": ["Turnix@ui.controls@^1.2"]
    "packs": ["avatars", "llm.pipeline"]

Rules (LOCKED):
- absence of "packs" means no dependencies
- empty list means explicitly no dependencies
- every entry is a HARD dependency
- order in the list carries no semantic meaning


===============================================================================
3. PACK REQUEST REFERENCE
===============================================================================

Dependencies are expressed using PackRequestRef.

Canonical grammar:
    [<author>@]<packTreeId>[@<semverRequirement>]

Grammar rules are defined in DESIGN AREA 4 and are LOCKED.

This document defines how PackRequests are interpreted as dependencies.


===============================================================================
4. HARD DEPENDENCY MODEL (LOCKED)
===============================================================================

All dependencies declared via "packs" are HARD.

Consequences:
- failure to resolve -> activation failure
- no automatic disabling
- no silent downgrade
- no implicit fallback
- no best-effort substitution

Optional, soft, or advisory dependencies do NOT exist in this model.


===============================================================================
5. RESOLUTION OVERVIEW
===============================================================================

Dependency resolution consists of:
1) resolution source determination
2) candidate enumeration and constraint application
3) deterministic selection or explicit failure

Resolution produces exactly one of:
- a single concrete pack identity
- a classified, surfaced failure

Resolution mechanics are defined in DESIGN AREA 4.
This area defines policy and source selection.


===============================================================================
6. RESOLUTION SOURCE MODEL (LOCKED)
===============================================================================

Every dependency is resolved from exactly ONE source.
Sources are mutually exclusive.

Defined sources:
A) SaveOnly
B) GlobalPinned
C) GlobalNormal

The resolver MUST NOT mix sources.
The resolver MUST NOT fall back between sources.


6.1 SaveOnly
------------

Applies when:
- the dependency's packTreeId is listed in savePack metadata as copied

Rules:
- ONLY copied packs inside the savePack are eligible
- global registry MUST NOT be consulted
- absence of the copied pack -> HARD ERROR

Saved packs:
- are identified by full identity (author + packTreeId + version)
- are owned by the savePack
- are immutable unless explicitly replaced
- are visible only within that save context


6.2 GlobalPinned
----------------

Applies when:
- the dependency is bound to a pin in savePack metadata

Rules:
- ONLY the pinned concrete identity is eligible
- resolution occurs in the global registry ONLY
- pinned identity missing -> HARD ERROR
- pin does NOT imply copying or saving

Pins express explicit historical intent.
They bypass all selector logic.


6.3 GlobalNormal
----------------

Applies in all other cases.

Rules:
- resolution occurs in the global registry ONLY
- no savePack content is consulted
- selection follows deterministic ordering rules (see Section 9)


===============================================================================
7. CANDIDATE ENUMERATION
===============================================================================

Within the selected source:
- collect packs matching packTreeId
- apply author constraint if present
- apply kind constraint if present
- apply hard constraints

No ordering.
No selection.
No policy decisions.

This phase answers only:
    "Which packs are structurally eligible?"


===============================================================================
8. VERSION CONSTRAINT ENFORCEMENT (LOCKED)
===============================================================================

If a semver requirement is present:

Concrete version:
- ONLY that version is eligible
- mismatch -> HARD FAILURE

Version range:
- only matching versions are eligible
- policy MAY restrict further

If no semver requirement or "*":
- all versions are eligible

If no eligible versions remain:
- resolution fails with VersionMismatchError


===============================================================================
9. GLOBALNORMAL SELECTION PROCEDURE (LOCKED)
===============================================================================

GlobalNormal resolution uses deterministic procedural ordering.
No scoring model exists.

Procedure:

STEP 1 - Version handling
-------------------------
- If a concrete version is specified:
    - only that version is eligible
- If a range or "*" is specified:
    - highest semantic version is preferred
- Packs without version metadata are ordered LAST

STEP 2 - Author relationship ordering
-------------------------------------
1) exact requested author
2) same author as requesting pack
3) different known author
4) unknown author

STEP 3 - Root precedence
------------------------
Enumeration order inherited from discovery:
    custom -> first-party -> third-party

STEP 4 - Final tie-break
------------------------
Lexicographic order of:
    "<author>@<packTreeId>@<version>"

Selection rule:
- FIRST eligible candidate is selected
- silent substitution is FORBIDDEN


===============================================================================
10. AMBIGUITY & USER INVOLVEMENT (LOCKED)
===============================================================================

If deterministic ordering cannot produce a single candidate:
- resolution MUST pause
- ambiguity MUST be surfaced
- user or policy input is REQUIRED

Once a decision is made:
- it MUST be persisted
- future runs MUST be deterministic

The resolver itself MUST NOT guess.


===============================================================================
11. FAILURE CONDITIONS (LOCKED)
===============================================================================

Dependency resolution fails if:
- no candidates remain after hard constraints
- resolution source rules are violated
- pinned or saved identity is missing
- ambiguity cannot be resolved

Failures MUST:
- be explicit
- be classified
- be observable (see DESIGN AREA 12)
- never silently fall back


===============================================================================
12. LAST-KNOWN-GOOD FALLBACK (LOCKED)
===============================================================================

Turnix stores the last successfully activated graph per savePack.

Rules:
- resolution ALWAYS attempts fresh resolution first
- last-known-good is NOT consulted during resolution
- fallback is used ONLY after activation failure

Fallback procedure:
1) abort current activation
2) attempt activation using stored graph
3) propagate failure if fallback fails


===============================================================================
13. DEPENDENCY != ACTIVATION
===============================================================================

Declaring or resolving a dependency:
- does NOT activate a pack
- does NOT load code
- does NOT grant runtime access

Activation semantics are defined in DESIGN AREA 8.


===============================================================================
14. LOCKED SUMMARY
===============================================================================

LOCKED:
- dependencies are hard contracts
- PackRequest interpretation is fixed
- resolution sources are exclusive
- saved packs are immutable and local
- pinned packs enforce exact identity
- GlobalNormal selection is procedural and deterministic
- no silent substitution
- ambiguity requires explicit decision

OPEN:
- none at semantic level
- only tooling and UI presentation remain open


===============================================================================
END OF DESIGN AREA 7 - DEPENDENCIES, REQUIREMENTS & PACK REQUESTS
===============================================================================


--- doc-meta ---
docId: docs/design/DA-07_DEPENDENCIES_REQUIREMENTS_AND_PACK_REQUESTS.txt
rev: 1
git: 0000000
----------------
