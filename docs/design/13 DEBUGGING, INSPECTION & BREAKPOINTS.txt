===============================================================================
DESIGN AREA 13 — DEBUGGING, INSPECTION & BREAKPOINTS
===============================================================================

Status:
-------
CORE (developer-facing) — this area defines *how Turnix can be inspected
while running*, *where execution can be paused*, and *how state can be
safely observed and modified* without breaking determinism.


===============================================================================
1. CORE INTENT
===============================================================================

Debugging in Turnix is not:
- print statements
- ad-hoc logging
- attaching debuggers to random threads

Debugging in Turnix is:
- intentional
- observable
- reversible
- scoped


===============================================================================
2. DEBUGGING PHILOSOPHY (LOCKED)
===============================================================================

Turnix debugging must:
- not change semantic behavior by default
- be opt-in
- preserve causality
- operate on *Turnix concepts*, not language internals

You debug:
- packs
- activation
- pipelines
- memory layers
- capabilities

NOT:
- Python frames
- JavaScript call stacks (except as contextual information)


===============================================================================
3. BREAKPOINT TYPES (LOCKED)
===============================================================================

Turnix supports *semantic breakpoints*, not code-line breakpoints.


3.1 Pipeline Stage Breakpoints
------------------------------
Pause execution when a pipeline reaches a specific stage.

Use cases:
- inspect prompt before sending to LLM
- verify memory composition
- observe transformations

Breakpoint triggers:
- stage id
- pipeline id
- optional condition


3.2 Memory Breakpoints
----------------------
Pause execution when memory changes.

Triggers:
- memory key
- memory layer
- change type (set, delete, overwrite)
- optional value predicate


-------------------------------------------------------------------------------
3.2.1 MEMORY BREAKPOINTS & TRANSACTIONAL STAGING (LOCKED)
-------------------------------------------------------------------------------

Memory breakpoints observe *state transitions*, not storage mechanics.

Definitions:

- A "staged mutation" is a write into a transactional layer.
- A "committed mutation" is a write that becomes visible in a committed
  (authoritative) memory layer after a successful commit.
- An "aborted mutation" is a staged mutation discarded during abort.

Rules (LOCKED):

1) By default, memory breakpoints MUST trigger on committed mutations only.

   - Writing into a transactional layer MUST NOT trigger a memory breakpoint.
   - Aborting a transaction MUST NOT trigger a memory breakpoint.
   - Only the moment a value becomes authoritative is breakpoint-visible.

2) Memory breakpoints MAY be configured to observe staged mutations explicitly.

   If enabled, a breakpoint MAY specify:
   - observeStaged = true
   - observeCommitted = true | false

   When observeStaged is enabled:
   - breakpoint triggers when a staged value is written
   - breakpoint context MUST include:
       - transaction id
       - staging layer identity
       - parent layer identity
       - commit eligibility status

3) Memory breakpoints MUST distinguish mutation phase.

   Every breakpoint hit MUST be classified as exactly one of:
   - StagedMutation
   - CommittedMutation

4) Breakpoints MUST NOT fire twice for the same mutation.

   If a breakpoint observes staged mutations and committed mutations:
   - the staged hit and committed hit are distinct events
   - both MUST be trace-linked to the same mutation lineage

5) Nested transactions inherit breakpoint semantics.

   - A breakpoint defined on a parent session applies to all child
     transactions unless explicitly scoped otherwise.
   - A child transaction commit into a parent transaction MUST NOT be
     treated as a committed mutation.

   Only the outermost transaction commit produces authoritative mutation
   events.

Rationale:

This model preserves determinism, prevents breakpoint storms during
speculative execution, and aligns debugging semantics with Turnix’s
transactional authority model (see DESIGN AREA 15).


3.3 Capability Breakpoints
--------------------------
Pause before or after a capability call.

Triggers:
- capability name
- caller pack
- permission decision point


===============================================================================
4. BREAKPOINT BEHAVIOR (LOCKED)
===============================================================================

When a breakpoint triggers:
- execution of the triggering unit pauses
- the rest of Turnix continues (unless configured otherwise)
- debugger UI is notified
- state becomes inspectable

Breakpoints NEVER:
- auto-resume silently
- alter execution order
- mutate state by default


===============================================================================
4.1 LIVE DEBUGGING WITHOUT PAUSE (LOCKED)
===============================================================================

The debugger MAY be used while Turnix is running normally.

LOCKED:
- Debugger inspection does NOT require a breakpoint to be hit.
- Debugger inspection does NOT require Turnix to be in a paused state.

Consequences:
- A user may open inspectors, browse state, and request read-only views
  at any time.
- Such inspection MUST be traceable and marked as debugger / tooling activity.


===============================================================================
4.2 DEBUGGER ACTIONS VS ORCHESTRATION (LOCKED)
===============================================================================

Debugger UI actions are executed via Turnix-controlled Remote Procedure Call
and capabilities.

LOCKED:
- Debugger tooling MUST NOT bypass Turnix orchestration.
- Debugger tooling MUST NOT access raw filesystem input/output.
- Any persistence-affecting action initiated by the debugger MUST execute
  through the same authority path as normal runtime actions
  (for example IoManager or services that use it).


===============================================================================
5. INSPECTION SURFACES (LOCKED)
===============================================================================

Inspectable objects include:
- PackDescriptors
- Activation state
- Memory layers
- Pipeline objects
- Capability registry
- Services registry

Inspection is read-only by default.


===============================================================================
6. CONTROLLED MUTATION (LOCKED)
===============================================================================

Explicit mutation is allowed ONLY via:
- debugger actions
- explicit user confirmation
- trace logging

Examples:
- editing a memory value
- disabling or modifying a breakpoint
- forcing resume or abort

Every mutation emits a trace event.


===============================================================================
6.1 MUTATION WHILE RUNNING (LOCKED)
===============================================================================

Controlled mutation MAY be performed while Turnix is active (not paused).

Rules:
- Mutation MUST be explicit (user action in debugger UI).
- Mutation MUST be traceable and labeled as debugger-initiated.
- Mutation MUST obey the same permission, ownership, and scope rules as
  normal runtime actions.

If a mutation affects data that active execution units may read
concurrently, the debugger MUST either:
- require a manual pause (see Section 6.2), OR
- enforce deterministic apply-at-safe-point semantics (see Section 6.3).


===============================================================================
6.2 MANUAL PAUSE (LOCKED)
===============================================================================

Turnix MAY support manual pausing even when no breakpoint is hit.

Purpose:
- allow deterministic inspection and mutation
- prevent important work from being voided by cancellation

LOCKED:
- Manual pause MUST be deterministic.
- Manual pause MUST NOT silently cancel in-flight work.
- If pausing cannot be achieved safely, Turnix MUST refuse the pause
  request with an explicit, traceable reason.

Manual pause MAY operate by enforcing quiescence at defined safe points:
- between pipeline stages
- between capability calls
- before commit points for persistence


===============================================================================
6.3 APPLY-AT-SAFE-POINT (LOCKED)
===============================================================================

When Turnix is not paused, debugger-initiated mutations MAY be staged and
applied only at a deterministic safe point.

Rules:
- Staging MUST be traceable.
- The exact safe point where the mutation becomes visible MUST be traceable.
- Staged mutations MUST NOT partially apply.
- If the safe point is never reached (for example execution aborts),
  the staged mutation MUST be discarded deterministically and traced.


===============================================================================
7. DEBUGGER UI INTEGRATION (LOCKED)
===============================================================================

Debugger UI:
- subscribes via RPC
- receives breakpoint hit events
- shows causal context
- allows resume / step / abort

Debugger UI is optional but supported.


===============================================================================
8. STEP MODES (LOCKED)
===============================================================================

Supported:
- Resume
- Step over (next stage / memory change)
- Abort (fail current execution unit)

Unsupported:
- instruction-level stepping
- time travel (future area)


===============================================================================
8.1 JOBS, LONG-RUNNING WORK & BREAKPOINTING (LOCKED)
===============================================================================

Turnix MAY represent long-running work as explicit Jobs.

If Jobs exist:
- Jobs MUST be observable (status, owner, causal trace links).
- Jobs MUST be abortable only through Turnix orchestration.

Debugger interaction with Jobs:
- A manual pause MUST NOT implicitly abort Jobs.
- A debugger MAY request:
    - pause-at-safe-point for a Job
    - breakpoint-at-safe-point for a Job
    - explicit Job abort

Safe-point pausing or breakpointing of Jobs occurs:
- between pipeline stages
- before or after capability boundaries
- before commit points for persistence

If a Job cannot reach a safe point:
- this MUST be surfaced explicitly
- no silent cancellation is permitted


===============================================================================
9. SCOPING RULES (LOCKED)
===============================================================================

Breakpoints can be scoped to:
- global
- appInstance
- view
- pack
- pipeline

Unscoped breakpoints are discouraged.


===============================================================================
10. DEV VS PROD (LOCKED)
===============================================================================

In production:
- breakpoints disabled by default
- inspection limited
- mutation disallowed unless explicitly enabled

In development:
- all features available


===============================================================================
11. FAILURE MODES (LOCKED)
===============================================================================

If debugger disconnects:
- execution resumes or aborts based on policy
- no deadlock allowed

If breakpoint logic errors:
- breakpoint disabled
- error traced


===============================================================================
12. RELATION TO TRACING (LOCKED)
===============================================================================

Every breakpoint hit:
- emits a trace event
- links to the causal chain
- records inspection and mutation actions

Tracing and debugging are complementary.


===============================================================================
13. WHAT IS EXPLICITLY NOT SUPPORTED
===============================================================================

NOT SUPPORTED:
- arbitrary Python debugger injection
- JavaScript eval debugging
- modifying pack code at runtime
- hot-patching logic without reload


===============================================================================
14. OPEN QUESTIONS
===============================================================================

OPEN:
- conditional breakpoint language
- snapshot / restore state
- time-travel debugging
- replay-from-trace tooling


===============================================================================
15. LOCKED SUMMARY
===============================================================================

LOCKED:
- semantic breakpoints
- pipeline, memory, and capability breakpoints
- transaction-aware breakpoint semantics
- read-only inspection by default
- controlled mutation with tracing
- debugger usable while Turnix is running
- deterministic manual pause
- apply-at-safe-point mutation semantics
- job-safe breakpointing and pausing
- non-blocking debugger behavior

OPEN:
- advanced conditional logic
- replay & time travel


===============================================================================
END OF DESIGN AREA 13
===============================================================================

--- doc-meta ---
docId: docs/design/13 DEBUGGING, INSPECTION & BREAKPOINTS.txt
rev: 4
git: 4b75e10
---------------
