===============================================================================
DESIGN AREA 5 — IMPORTING, MODULE LOADING & CODE BOUNDARIES
===============================================================================

Status:
-------
CORE — this area defines *how code is referenced, loaded, and executed*
across Python and JavaScript, and where hard boundaries exist.

This area is intentionally strict.
Importing is NOT resolution.
Importing is NOT activation.
Importing is NOT dependency declaration.


===============================================================================
1. CORE PROBLEM STATEMENT
===============================================================================

Turnix does NOT allow arbitrary language-native importing across packs.

Reasons:
- Files live in multiple roots with precedence rules
- Packs may be overridden, pinned, copied, or disabled
- Activation order is controlled by PackManager
- Silent code execution is forbidden

Therefore:
- All cross-pack code access MUST go through Turnix mechanisms
- Native imports are allowed ONLY for:
    - language internals
    - same-file or same-directory code
    - Turnix core internals (explicitly)


===============================================================================
2. PYTHON IMPORT RULES (LOCKED)
===============================================================================

Allowed:
    from .llamacpp_client import LlamaCppClient
    from .config import loadConfig

Meaning:
- Local file import
- Same directory only
- Normal Python semantics

Allowed (INTERNALS ONLY):
    from backend.core.globals import configBool

Disallowed:
    from ui.controls import Button
    from Turnix.ui.controls import Button
    from first_party.mods.foo import bar

Rationale:
- Python interpreter has no awareness of Turnix pack resolution
- Allowing this would bypass visibility, pinning, overrides, saves


===============================================================================
3. PYTHON CROSS-PACK ACCESS (LOCKED MECHANISMS)
===============================================================================

Python mods interact with other packs ONLY via:

A) Services
    ctx.registerService(name, instance)
    ctx.services.get(name)

B) Capabilities
    ctx.callCapability("llm.pipeline@1", args)

C) Pack resolution (metadata only)
    ctx.resolvePack(selector)
    ctx.ensureActivated(selector)

There is NO Python equivalent of turnixImport.


===============================================================================
4. JAVASCRIPT IMPORT MODEL (LOCKED)
===============================================================================

JavaScript runs in browser context.
No Node.js.
No filesystem access.
No import maps for packs.

All dynamic loading goes through:

    turnixImport(selector)

(turnixResolve name reserved but not yet renamed)


===============================================================================
5. turnixImport — WHAT IT IS
===============================================================================

turnixImport(selector: string) is:

- a resolver
- a loader
- a controlled ESM importer
- NOT equivalent to native import()

It:
- parses selector
- asks backend to resolve pack + path
- fetches compiled JS via HTTP
- performs dynamic import()


===============================================================================
6. turnixImport — WHAT IT IS NOT
===============================================================================

turnixImport is NOT:
- dependency declaration
- activation request
- visibility override
- permissive loader

If resolution fails → hard error.


===============================================================================
7. turnixImport SELECTOR FORMS (LOCKED)
===============================================================================

Selector is NOT a filesystem path.
Selector is NOT a URI.
Selector is a *Turnix selector*.

Supported forms:

A) Core / internal runtime files
    "core/rpc.js"
    "core/layout.js"

→ resolved relative to WEB_ROOT

B) Pack default entry
    "ui.controls"

→ requires dependency on ui.controls
→ loads runtimes.javascript.entry

C) Pack sub-entry / export
    "ui.controls/Button"

→ resolves against runtimes.javascript.entries

Disallowed:
    "../"
    absolute paths
    filesystem guessing
    semver in selector
    author mismatch with dependency


===============================================================================
8. DEPENDENCY CONSISTENCY RULE (LOCKED)
===============================================================================

If a pack declares dependency:

    "packs": ["Turnix@ui.controls@^1.2"]

Then allowed imports:
    turnixImport("ui.controls")
    turnixImport("ui.controls/Button")

Disallowed:
    turnixImport("Other@ui.controls")
    turnixImport("ui.controls@2.0")

Violations → hard error.


===============================================================================
9. SEMVER IN IMPORTS (LOCKED)
===============================================================================

Semver is NOT allowed in turnixImport selectors.

Semver belongs to:
- manifests
- resolution
- policy

Importing is identity-based, not version-based.


===============================================================================
10. FILE MATCHING RULES (LOCKED)
===============================================================================

For sub-entry import:

    turnixImport("ui.controls/Button")

Resolution logic:
- Look into runtimes.javascript.entries
- Match:
    - exact "Button"
    - or "Button.<extension>"

Allowed extensions:
- .js
- .mjs
- .ts (compiled)

Ambiguous matches → error
No match → error
No fallback to entry


===============================================================================
11. DEFAULT ENTRY BEHAVIOR (LOCKED)
===============================================================================

If selector has NO sub-path:

    turnixImport("ui.controls")

Then:
- runtimes.javascript.entry MUST exist
- it is loaded
- module exports are returned

No implicit index.js guessing.


===============================================================================
12. ACTIVATION VS IMPORT (CRITICAL)
===============================================================================

turnixImport:
- loads JS module
- executes ESM evaluation
- DOES NOT guarantee pack activation

Activation is handled separately via:
- PackManager
- ensureActivated


===============================================================================
13. ensureActivated / resolvePack (LOCKED SEMANTICS)
===============================================================================

resolvePack(selector):
- resolves metadata
- does NOT load code
- may throw NotFoundError

ensureActivated(selector):
- ensures pack activation
- does NOT return exports
- may return activation result metadata
- may throw NotActivatedError

Handling NotActivatedError is discouraged.
It indicates activation-order failure and should surface to user.


===============================================================================
14. GLOBAL SCOPE & SIDE EFFECTS (LOCKED POLICY)
===============================================================================

JavaScript:
- ESM evaluation happens on import
- Side effects are allowed but discouraged
- All Turnix interaction MUST occur via onLoad(ctx)

Python:
- module top-level executes on importlib load
- only local imports allowed
- onLoad(ctx) is canonical entrypoint


===============================================================================
15. CANONICAL ENTRYPOINTS (LOCKED)
===============================================================================

Currently:
    onLoad(ctx)

Rules:
- Called exactly once by Turnix
- Must prepare the pack
- No further initialization opportunity guaranteed

Future entrypoints may exist.


===============================================================================
16. BACKGROUND WORK GUARANTEE (LOCKED)
===============================================================================

Turnix does NOT guarantee behavior for background work started
outside Turnix orchestration.

Only work triggered by:
- entrypoints
- capability calls
is supported.


===============================================================================
17. ERROR PHILOSOPHY (LOCKED)
===============================================================================

Import errors are HARD errors.

Reasons:
- import implies certainty
- permissive mode causes nondeterminism
- failures must be visible

Errors must use standard error envelope.


===============================================================================
18. OPEN QUESTIONS
===============================================================================

OPEN:
- possible rename turnixImport → turnixResolve
- tooling for authoring entries mapping
- documentation wording to avoid Python-import confusion


===============================================================================
19. LOCKED SUMMARY
===============================================================================

LOCKED:
- no Python cross-pack imports
- JS uses turnixImport only
- no semver in imports
- dependency consistency enforced
- strict errors
- activation separate from import

OPEN:
- naming polish
- authoring ergonomics


===============================================================================
END OF DESIGN AREA 5
===============================================================================

--- doc-meta ---
docId: docs/design/05 IMPORTING, MODULE LOADING & CODE BOUNDARIES.txt
rev: 3
git: 53e7920
---------------
