===============================================================================
DESIGN AREA 5 — IMPORTING, MODULE LOADING & CODE BOUNDARIES
===============================================================================

Status:
-------
CORE — this area defines how code is referenced, loaded, and made available
across supported languages, and where strict boundaries exist between
resolution, importing, activation, and execution.

This area is intentionally strict.

Importing is NOT resolution.
Importing is NOT activation.
Importing is NOT dependency declaration.
Importing does NOT imply permission to execute.


===============================================================================
1. CORE PROBLEM STATEMENT
===============================================================================

Turnix does NOT allow arbitrary language-native importing across packs.

Reasons:
- Files live in multiple roots with precedence rules
- Packs may be overridden, pinned, copied, disabled, or save-scoped
- Activation order is centrally controlled
- Silent or implicit code execution is forbidden
- Native language import systems have no awareness of Turnix semantics

Therefore:

- All cross-pack code access MUST go through Turnix-defined mechanisms
- Native imports are allowed ONLY for:
    - language internals
    - same-file or same-directory code
    - Turnix core internals (explicitly whitelisted)

Any mechanism that bypasses Turnix resolution, visibility, or activation
boundaries is forbidden.


===============================================================================
2. PYTHON IMPORT RULES (LOCKED)
===============================================================================

Allowed:

    from .llamacpp_client import LlamaCppClient
    from .config import loadConfig

Meaning:
- Local file import
- Same directory only
- Standard Python semantics

Allowed (TURNIX INTERNALS ONLY):

    from backend.core.globals import configBool

Disallowed:

    from ui.controls import Button
    from Turnix.ui.controls import Button
    from first_party.mods.foo import bar

Rationale:
- Python import machinery has no awareness of:
    - pack resolution
    - visibility
    - pinning
    - savePack scoping
- Allowing cross-pack Python imports would bypass all Turnix guarantees


===============================================================================
3. PYTHON CROSS-PACK ACCESS (LOCKED MECHANISMS)
===============================================================================

Python pack code may interact with other packs ONLY via Turnix-mediated APIs:

A) Services
    ctx.registerService(name, instance)
    ctx.services.get(name)

B) Capabilities
    ctx.callCapability("llm.pipeline@1", args)

C) Pack metadata & activation control
    ctx.resolvePack(selector)
    ctx.ensureActivated(selector)

There is NO Python equivalent of turnixImport.
Python code never receives executable code or symbols from other packs.


===============================================================================
4. JAVASCRIPT IMPORT MODEL (LOCKED)
===============================================================================

JavaScript runs in a browser environment.

Constraints:
- No Node.js
- No filesystem access
- No per-pack import maps
- No native cross-pack imports

All dynamic cross-pack loading goes through:

    turnixImport(selector)

(Name turnixResolve is reserved but not yet finalized.)


===============================================================================
5. turnixImport — WHAT IT IS
===============================================================================

turnixImport(selector: string) is:

- a Turnix-aware resolver
- a controlled loader
- a mediated ESM importer
- NOT equivalent to native import()

Behavior:
- parses a Turnix selector
- asks the backend to resolve pack identity and path
- performs visibility and policy checks
- fetches compiled JavaScript via HTTP
- performs dynamic ESM import


===============================================================================
6. turnixImport — WHAT IT IS NOT
===============================================================================

turnixImport is NOT:
- a dependency declaration
- an activation request
- a visibility override
- a permissive or best-effort loader
- a version selector

If resolution fails:
→ a HARD error is raised


===============================================================================
7. turnixImport SELECTOR FORMS (LOCKED)
===============================================================================

Selector is NOT:
- a filesystem path
- a URI
- a semver-qualified reference

Selector IS:
- a Turnix identity-based selector

Supported forms:

A) Core / internal runtime files

    "core/rpc.js"
    "core/layout.js"

→ resolved relative to WEB_ROOT

B) Pack default entry

    "ui.controls"

→ requires declared dependency on ui.controls
→ loads runtimes.javascript.entry

C) Pack sub-entry / export

    "ui.controls/Button"

→ resolves against runtimes.javascript.entries

Disallowed:
- "../"
- absolute paths
- filesystem guessing
- semver in selector
- author mismatch with declared dependency


===============================================================================
8. DEPENDENCY CONSISTENCY RULE (LOCKED)
===============================================================================

If a pack declares dependency:

    "packs": ["Turnix@ui.controls@^1.2"]

Then allowed imports:

    turnixImport("ui.controls")
    turnixImport("ui.controls/Button")

Disallowed:

    turnixImport("Other@ui.controls")
    turnixImport("ui.controls@2.0")

Violations result in HARD errors.

Importing MUST respect the exact resolved identity
chosen during dependency resolution.


===============================================================================
9. SEMVER IN IMPORTS (LOCKED)
===============================================================================

Semver is NOT allowed in turnixImport selectors.

Semver belongs to:
- manifests
- dependency resolution
- policy decisions

Importing is identity-based, never version-based.


===============================================================================
10. FILE MATCHING RULES (LOCKED)
===============================================================================

For sub-entry imports:

    turnixImport("ui.controls/Button")

Resolution logic:
- inspect runtimes.javascript.entries
- match:
    - exact "Button"
    - or "Button.<extension>"

Allowed extensions:
- .js
- .mjs
- .ts (compiled)

Rules:
- ambiguous matches → error
- no match → error
- no fallback to runtimes.javascript.entry


===============================================================================
11. DEFAULT ENTRY BEHAVIOR (LOCKED)
===============================================================================

If selector has NO sub-path:

    turnixImport("ui.controls")

Then:
- runtimes.javascript.entry MUST exist
- it is loaded
- module exports are returned

No implicit index.js or filename guessing is allowed.


===============================================================================
12. IMPORTING VS ACTIVATION (CRITICAL DISTINCTION)
===============================================================================

turnixImport:
- loads a JavaScript module
- triggers ESM evaluation
- DOES NOT guarantee pack activation
- DOES NOT grant execution authority

turnixImport MAY load code only if the pack is eligible
according to activation and visibility policy,
but it NEVER triggers activation.

Activation is handled exclusively via:
- PackManager
- ensureActivated(selector)


===============================================================================
13. resolvePack vs ensureActivated (LOCKED SEMANTICS)
===============================================================================

resolvePack(selector):
- resolves metadata only
- performs visibility checks
- does NOT load code
- does NOT activate

ensureActivated(selector):
- ensures pack activation
- may trigger activation
- does NOT return exports or symbols
- may return activation diagnostics
- may throw NotActivatedError

NotActivatedError indicates orchestration failure
and SHOULD surface to the user.


===============================================================================
14. IMMEDIATE EXECUTION & SIDE EFFECTS (LOCKED POLICY)
===============================================================================

Some languages allow immediate execution constructs, including:
- module-level statements
- IIFE-style patterns
- top-level side effects

Turnix rules:

- Turnix does NOT coordinate or rely on immediate execution
- Immediate execution is DISCOURAGED in all pack code
- Importing a module does NOT imply permission to execute logic

Code that executes immediately:
- runs outside Turnix orchestration
- runs without PackContext authority
- is outside Turnix guarantees

All meaningful execution MUST wait for:

    onLoad(ctx)

This rule applies uniformly to:
- Python
- JavaScript
- any future supported language


===============================================================================
15. CANONICAL ENTRYPOINTS (LOCKED)
===============================================================================

Currently supported entrypoint:

    onLoad(ctx)

Rules:
- called exactly once by Turnix
- is the ONLY supported initialization point
- must prepare the pack for runtime behavior

No other execution point is guaranteed.


===============================================================================
16. BACKGROUND WORK GUARANTEE (LOCKED)
===============================================================================

Turnix does NOT guarantee behavior for background work started
outside Turnix orchestration.

Only work initiated via:
- activation entrypoints
- capability calls
is supported.

Background work started otherwise:
- may execute
- but is unsupported
- untracked
- not abortable
- not cleaned up


===============================================================================
17. ERROR PHILOSOPHY (LOCKED)
===============================================================================

Import errors are HARD errors.

Rationale:
- importing implies certainty
- permissive loading causes nondeterminism
- failures must be visible and explainable

All import-related errors MUST:
- use the standard error envelope
- include requesting pack identity
- include target identity
- include reason classification


===============================================================================
18. OPEN QUESTIONS
===============================================================================

OPEN (NON-SEMANTIC):
- possible rename turnixImport → turnixResolve
- tooling for authoring entries mapping
- documentation wording to avoid Python-import confusion


===============================================================================
19. LOCKED SUMMARY
===============================================================================

LOCKED:
- no Python cross-pack imports
- JavaScript cross-pack loading via turnixImport only
- importing does NOT imply activation or execution
- no semver in imports
- dependency consistency enforced
- immediate execution (IIFE / top-level code) is discouraged and unsupported
- onLoad(ctx) is the only supported execution entrypoint
- strict, visible errors
- activation is separate from import

OPEN:
- naming polish
- authoring ergonomics


===============================================================================
END OF DESIGN AREA 5
===============================================================================

--- doc-meta ---
docId: docs/design/05 IMPORTING, MODULE LOADING & CODE BOUNDARIES.txt
rev: 4
git: d1b3b4b
---------------
