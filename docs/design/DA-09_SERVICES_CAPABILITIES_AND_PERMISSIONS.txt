===============================================================================
DESIGN AREA 9 - SERVICES, CAPABILITIES & PERMISSIONS
===============================================================================

Status:
-------
CORE - this area defines how packs interact at runtime without importing
each other's code, and how Turnix mediates authority, power, and safety.

This is the primary and ONLY supported cross-pack interaction mechanism.


===============================================================================
1. CORE DISTINCTION
===============================================================================

Turnix defines two orthogonal runtime interaction mechanisms:
- Services     -> shared runtime objects (wiring)
- Capabilities -> named, permissioned operations (authority)

They serve different purposes and MUST NOT be conflated.

Neither Services nor Capabilities imply persistence.
Persistence is governed exclusively by:
- File I/O (DA-10)
- Configuration & schemas (DA-11)


===============================================================================
2. SERVICES - RUNTIME WIRING (LOCKED)
===============================================================================

A Service is:
- a concrete runtime object or instance
- registered by a pack during activation
- stored in a scoped service registry
- retrieved explicitly by other packs

Example:
    ctx.registerService("llm", client)
    client = ctx.services.get("llm")

Properties (LOCKED):
- services are opaque objects
- lifetime is bound to the providing pack's activation
- name collisions are forbidden
- services MUST NOT perform filesystem I/O directly
- services have NO permission layer


===============================================================================
3. SERVICE ACCESS RULES (LOCKED)
===============================================================================

- Service access is explicit
- No inheritance
- No visibility-based granting
- No implicit availability

If a service does not exist:
- ctx.services.get(name) MUST fail
  (or return None only if explicitly allowed by API contract)

Services are for trusted runtime wiring ONLY.
They MUST NOT be used to bypass:
- configuration schemas
- persistence rules
- permission checks


===============================================================================
4. CAPABILITIES - EXECUTION BOUNDARY (LOCKED)
===============================================================================

A Capability is:
- a named operation
- exported by a pack
- invoked by other packs
- mediated by Turnix
- permission-checked

Capabilities are the ONLY supported cross-pack execution boundary.

Example (export):
    ctx.registerCapability("llm.pipeline@1", handler)

Example (call):
    ctx.callCapability("llm.pipeline@1", args)


===============================================================================
5. CAPABILITY IDENTITIES & VERSIONING (LOCKED)
===============================================================================

Capability identifiers:
    <name>@<major>

Examples:
    "llm.pipeline@1"
    "http.request@1"
    "compile.typescript@1"

Rules (LOCKED):
- major version only
- incompatible change -> new major
- no minor or patch versions
- capability identity is stable and global


===============================================================================
6. CAPABILITY EXPORT VS USAGE (LOCKED DISTINCTION)
===============================================================================

Export:
- happens at runtime via ctx.registerCapability
- defines the authoritative behavior

Usage:
- happens via ctx.callCapability
- invokes Turnix mediation

Manifest declarations:
- OPTIONAL
- advisory only
- used for tooling, diagnostics, and UX
- never authoritative

Runtime behavior always wins over manifest intent.


===============================================================================
7. PERMISSIONS MODEL (LOCKED CORE)
===============================================================================

Each capability declares a permission class, immutable per major version:
- none
    -> always allowed
- soft
    -> user may be prompted
    -> allow / deny / remember
- hard
    -> user MUST explicitly allow
    -> cannot be auto-granted

Permission classification is capability-defined and non-negotiable.


===============================================================================
8. CAPABILITY INVOCATION FLOW (LOCKED)
===============================================================================

When ctx.callCapability(...) is invoked:

1) Turnix evaluates permission
2) If allowed -> handler executes
3) If undecided:
    - execution PAUSES
    - UI prompt is shown
    - user decision is recorded
    - execution resumes

LOCKED:
- Turnix MUST remain responsive during pause
- no background mutation may occur while paused
- execution resumes deterministically from the pause point


===============================================================================
9. USER DECISIONS & POLICY (LOCKED)
===============================================================================

User decisions:
- may be persisted
- may be scoped (session / app / global)
- MUST be explainable
- MUST be reversible

Policies may define:
- auto-allow behavior for soft permissions
- never-auto-allow behavior for hard permissions

All decisions MUST be:
- traceable
- attributable
- replayable


===============================================================================
10. SERVICES VS CAPABILITIES - STRICT SEPARATION
===============================================================================

Services:
- direct object access
- no permission checks
- internal wiring only

Capabilities:
- explicit execution boundary
- user-visible power
- permissioned and audited

LOCKED:
- capabilities MUST NOT expose service internals directly
- services MUST NOT be callable across packs without capability mediation


===============================================================================
11. COMPUTED & REACTIVE BEHAVIOR (LOCKED CLARIFICATION)
===============================================================================

Some packs may react to runtime state or configuration changes by:
- observing values
- computing derived behavior
- adjusting runtime output

Rules (LOCKED):
- behavior MUST be runtime-only
- MUST NOT mutate stored configuration or memory
- MUST NOT intercept persistence
- MUST NOT replace the source of truth

Allowed mechanisms:
- capability invocation
- service cooperation
- config/watch-style notifications (DA-11)

This preserves:
- determinism
- reversibility
- non-invasive overrides (e.g. accessibility scaling)


===============================================================================
12. CONFLICTS & OVERRIDES (LOCKED)
===============================================================================

Multiple packs exporting the same capability identity:
- NOT allowed by default
- conflict MUST be detected
- resolution requires:
    - explicit user choice
    - or hard error

Silent override is forbidden.


===============================================================================
13. TRACE & AUDIT (LOCKED)
===============================================================================

All capability calls:
- are traceable
- include caller identity
- include permission context
- record outcome (allowed / denied / failed)

Trace MUST distinguish:
- stored mutation
- computed effect
- denied access

This is required for debugging, trust, and reproducibility.


===============================================================================
14. DEVELOPMENT-TIME DIAGNOSTICS (LOCKED)
===============================================================================

In development mode, Turnix reports:
- declared-but-unused capabilities
- used-but-undeclared capabilities
- exported-but-never-called capabilities

These reports are:
- informational
- non-fatal
- tooling-oriented


===============================================================================
15. CROSS-RUNTIME SYMMETRY (LOCKED)
===============================================================================

The same model applies to Python and JavaScript:
- Python packs expose capabilities usable by JavaScript
- JavaScript UI invokes Python logic via capabilities
- no direct cross-language object access exists

Capabilities are the universal boundary.


===============================================================================
16. OPEN QUESTIONS
===============================================================================

OPEN:
- fine-grained permission scopes
- capability discovery and browsing UI
- dynamic permission revocation
- subscription-based or streaming capabilities


===============================================================================
17. LOCKED SUMMARY
===============================================================================

LOCKED:
- services are runtime wiring only
- capabilities are the sole execution boundary
- permission model is explicit and immutable per major
- no implicit persistence
- no silent overrides
- full tracing and audit

OPEN:
- UX and policy extensions only


===============================================================================
END OF DESIGN AREA 9 - SERVICES, CAPABILITIES & PERMISSIONS
===============================================================================


--- doc-meta ---
docId: docs/design/DA-09_SERVICES_CAPABILITIES_AND_PERMISSIONS.txt
rev: 1
git: 0000000
----------------
