===============================================================================
DESIGN AREA 15 — MEMORY, STATE, LAYERS & JOURNALING
===============================================================================

Status:
-------
CORE — this area defines how runtime state exists, how it is layered,
how mutations are staged and committed, how persistence is handled,
and how historical evidence is recorded without compromising determinism
or safety.


===============================================================================
1. CORE INTENT
===============================================================================

This design area defines:

- what "memory" means in Turnix
- how state is layered, staged, and committed
- how persistence relates to runtime memory
- how historical evidence is recorded
- what is authoritative state vs observational data
- how inspection, rollback, and audit are supported

Turnix MUST:
- preserve deterministic state evolution
- support rollback and reproducibility
- allow inspection and auditing
- avoid unbounded growth or silent data loss

Turnix MUST NOT:
- conflate state with logs or traces
- require infinite retention
- make silent pruning decisions


===============================================================================
2. MEMORY VS STATE (LOCKED)
===============================================================================

Memory is the runtime representation of values.
State is the authoritative, persisted outcome of committed memory.

Memory MAY exist without persistence.
Persistence MAY exist without memory being resident.

Only committed state is authoritative.


===============================================================================
3. MEMORY LAYERS (LOCKED)
===============================================================================

Turnix manages memory as a set of layered stores.

Layers represent:
- authority
- scope
- lifetime
- rollback boundaries

Examples of layers include (non-exhaustive):
- kernel-global
- appInstance
- session
- view
- transactional

There is NO single "global memory object".
Each layer contains real values.


===============================================================================
4. TRANSACTIONAL STAGING MODEL (LOCKED)
===============================================================================

A transactional layer is a temporary memory layer created to stage mutations.

Properties:
- overlays one or more parent layers
- captures all writes during its lifetime
- allows reads from parent layers
- is resolved only by commit or abort

Primary usage:
- pipeline execution
- capability calls with mutation
- debugger-initiated staging

On commit:
- values propagate to their target authoritative layers

On abort:
- all staged mutations are discarded deterministically


===============================================================================
5. NESTED PIPELINE RUNS & TRANSACTION STACKING (LOCKED)
===============================================================================

If a pipeline run creates or enters another session (a child session) while
an enclosing pipeline run is active, the child session MUST inherit the
enclosing transactional view.

Effective read/write stack:

    kernel layer
    appInstance layer
    parent session layer
    parent transaction layer (txnParent)
    child transaction layer  (txnChild)

Rules (LOCKED):
- Reads resolve first-match from txnChild downward.
- Writes always target txnChild.
- Committing txnChild propagates its writes into txnParent.
- No child transaction may commit directly into committed layers while an
  enclosing transaction exists.
- Only the outermost transaction commit may mutate committed layers.

This prevents lost updates and desynchronization between pipeline runs.


===============================================================================
6. COMMIT, ABORT & DETERMINISM (LOCKED)
===============================================================================

A transaction MUST end in exactly one outcome:
- commit
- abort

Partial propagation is forbidden.

Commit and abort:
- are atomic
- are trace-backed
- preserve rollback guarantees


===============================================================================
7. COMMIT CONFLICT DETECTION (LOCKED)
===============================================================================

Each transaction records, per key, the base revision id visible at the time
the key was first read or first written within that transaction.

When committing into committed layers:
- if the committed layer's latest revision id differs from the recorded base
  revision id, the commit is in conflict and MUST fail deterministically.

No silent merge, no last-write-wins, and no heuristic reconciliation is allowed.
Any override requires explicit user or policy decision (DA-14).


===============================================================================
8. ORCHESTRATION CONCURRENCY MODEL (LOCKED)
===============================================================================

Turnix orchestrates execution in a deterministic single-lane model.

Within a given AppInstance, Turnix MUST NOT execute multiple orchestration
units concurrently.

Orchestration units include (non-exhaustive):
- pipeline stage callbacks
- capability handlers
- memory/config mutation requests
- debugger-initiated mutations

Awaited I/O or model calls may suspend the current unit, but MUST NOT allow
another unit that can mutate the same AppInstance state to run concurrently
unless an explicit concurrency mode is enabled by the kernel.

Work started outside Turnix orchestration is outside Turnix guarantees.
Any mutation MUST re-enter through orchestration boundaries.


===============================================================================
9. PERSISTENCE MODEL (LOCKED)
===============================================================================

Persistence is protection against loss, not the definition of state.

Rules:
- any committed value MAY be persisted
- persistence is handled exclusively by Turnix
- persistence is asynchronous but ordered
- failure to persist MUST be trace-visible

Persistence does not imply:
- immediate disk residency
- exclusive in-memory presence
- unlimited retention


===============================================================================
10. STATIC DATA & MUTATION INTENT (LOCKED)
===============================================================================

Static data is data provided by:
- packs
- configuration
- bundled resources

Static data is read-only by default.

When a mutation is attempted on static data, intent MUST be explicit:

A) Patch
   - original key remains authoritative
   - patch is applied on each read
   - patch is persisted as overlay data

B) Copy
   - a new key is created
   - data is copied and modified
   - original remains unchanged

This decision MAY require user interaction (DA-14).


===============================================================================
11. REVISIONS & STATE GARBAGE COLLECTION (LOCKED)
===============================================================================

Committed state values MAY have revisions.

Revisions exist to support:
- rollback
- auditing
- debugging

Revision retention is policy-driven.

Garbage collection MAY remove:
- old revisions
- unreachable historical states

Garbage collection MUST NOT:
- remove data required to reconstruct current committed state
- occur silently
- violate rollback guarantees


===============================================================================
12. JOURNAL — OBSERVATIONAL EVIDENCE (LOCKED)
===============================================================================

The journal records observational evidence of system activity.

Journal is:
- append-only
- non-authoritative
- non-blocking
- trace-adjacent

Examples:
- raw user input attempts
- raw assistant output (including aborted streams)
- intermediate pipeline artifacts
- debugging captures

Journal data is NOT state.
Journal data is NOT required for correctness.


===============================================================================
13. JOURNAL RETENTION MODEL (LOCKED)
===============================================================================

Journal retention follows a best-effort model.

LOCKED MEANING:
- If retention limits are exceeded (size, age, quota), older journal entries
  MAY be pruned.
- If storage is unavailable or under severe pressure, journal writes MAY be
  dropped rather than blocking execution.
- Any pruning or dropped writes MUST be trace-visible and classified.

Journal loss MUST NOT affect correctness.


===============================================================================
14. JOURNAL RETENTION POLICIES (LOCKED)
===============================================================================

Retention policies MAY include:
- maximum total size
- maximum age
- per-appInstance quota
- per-save quota
- per-category quota

Policies are:
- explicit
- inspectable
- configurable

Journal garbage collection:
- occurs incrementally
- emits trace events (what, why, policy)
- MUST NOT block execution


===============================================================================
15. JOURNAL RETENTION CLASSES (LOCKED)
===============================================================================

Journal entries MAY declare a retention class:

A) ephemeral
   - safe to prune aggressively
   - streaming chunks, transient outputs

B) bounded
   - retained per policy
   - suitable for post-mortem analysis

C) pinned
   - pruned only by explicit user action
   - SHOULD be used sparingly

Retention class affects garbage collection only.


===============================================================================
16. MEMORY INSPECTOR & TOOLING SEMANTICS (LOCKED STATE CONTRACT)
===============================================================================

The Memory Inspector is a tooling surface for observing and manipulating
Turnix-managed memory.

This section defines memory and state semantics only.
Breakpoint triggering, pause behavior, and execution control are governed
by DA-13.

Capabilities:
- enumerate memory layers and their composition
- inspect values with:
    - origin layer
    - revision identifiers
    - transactional visibility
- view active transactional stacks
- inspect staged vs committed values

Transactional interaction:
- Inspector-initiated edits MUST occur inside a transaction.
- The inspector MAY create its own temporary transactional overlay.
- Inspector transactions follow the same commit / abort rules as runtime
  transactions.
- Inspector commits propagate only one layer downward.
- Inspector actions MUST NOT finalize committed state mid-pipeline.

Undo / redo semantics:
- Undo operates on committed revisions.
- Redo is inspector-local, ephemeral, and non-authoritative.
- Redo history MUST be discarded deterministically when a new revision
  is committed.

Breakpoints and change observation:
- Memory breakpoints MAY observe:
    - committed layer mutations
    - transactional layer mutations
- Whether transactional changes trigger breakpoints is defined by DA-13
  breakpoint configuration and safe-point rules.

Debugger-initiated mutation:
- Obeys all ownership, permission, and scope rules.
- Is trace-labeled as tooling activity.
- May be staged and applied at safe points (DA-13).


===============================================================================
17. SNAPSHOTS AND EXPORTS
===============================================================================

A snapshot captures a point-in-time view of committed state.

LOCKED-IN-INTENT FOR OPEN SECTION:
- snapshots MUST be derived from committed layers only
- snapshots MUST NOT include transactional layers
- snapshot creation MUST be trace-visible

Export is a serialization of snapshot contents for external storage or
transfer.

Export formats MAY include:
- full SavePack snapshot
- state-only export (no journal)
- journal-only export (no state)
- minimal audit bundle (defined below)

Snapshots and exports MUST be immutable once created.


===============================================================================
18. ORCHESTRATION UNIT
===============================================================================

An Orchestration Unit is a kernel-tracked execution unit that is permitted
to mutate Turnix-managed state within an AppInstance.

Examples (non-exhaustive):
- a pipeline run, including its stage callbacks
- a capability handler invocation
- a debugger-initiated mutation transaction
- config mutation request processing

Work started outside Turnix orchestration is not an Orchestration Unit until
it re-enters through Turnix orchestration boundaries.


===============================================================================
19. SNAPSHOT REQUEST MODES
===============================================================================

Turnix MAY support multiple snapshot request modes.

Mode A: ImmediateCommitted

Meaning:
- snapshot captures committed layers only
- snapshot creation MUST NOT wait for quiescence
- snapshot creation MUST NOT fail due to active Orchestration Units
- snapshot metadata MUST include whether any Orchestration Unit was active

Mode B: AtQuiescence

Meaning:
- snapshot is created only when no Orchestration Unit is active for the
  target AppInstance
- the request MAY be queued until quiescence is reached

If Mode B is supported, it MUST be policy-bounded as defined below.


===============================================================================
20. ATQUIESCENCE QUEUEING AND POLICY BOUNDS
===============================================================================

If AtQuiescence is requested while an Orchestration Unit is active:

- Turnix MAY queue the request until quiescence is reached.
- Turnix MUST emit a trace event at request time indicating the request is
  pending and not yet satisfied.
- Turnix MUST emit a trace event when the snapshot is created, or when the
  request fails.

If queued requests are not persisted, this MUST be explicit:
- a queued AtQuiescence request MAY be lost on crash or restart
- loss MUST NOT be silent and MUST be trace-visible before the crash point
  when possible

AtQuiescence requests MUST be bounded by explicit policy. Policy options:

A) Timeout

- the request MUST fail deterministically after the configured time limit
  if quiescence is not reached

B) PauseAtSafePoint

- Turnix MAY attempt a deterministic pause at a defined safe point as
  described in DA-13
- if safe-point pause cannot be achieved safely, Turnix MUST fail the
  request with an explicit reason

AtQuiescence MUST NOT:
- silently wait forever
- silently cancel in-flight work
- silently downgrade into ImmediateCommitted without explicit user or policy


===============================================================================
21. TRACE DIRECTED ACYCLIC GRAPH (TRACE DAG) (LOCKED)
===============================================================================

Turnix tracing is modeled as a Trace Directed Acyclic Graph (trace DAG).

Definition:
- A trace DAG is a directed acyclic graph of trace events.
- Each trace event MAY reference zero or more parent trace events.
- Cycles are forbidden.

Trace DAG properties:
- Causality is explicit.
- Temporal order is NOT authoritative.
- Multiple parent links are permitted.
- Absence of a parent link implies independent origin, not simultaneity.

Trace DAG guarantees:
- Every decision-producing action MUST emit at least one trace event.
- Every trace event MUST belong to exactly one trace DAG.
- Trace DAG identity MUST be stable across export and inspection.

Naming:
- "Trace Directed Acyclic Graph" is the canonical name.
- "trace DAG" is the permitted abbreviation.

Trace DAG is authoritative for:
- causal explanation
- audit reconstruction
- debugger correlation
- policy enforcement provenance

Trace DAG is NOT authoritative for:
- state reconstruction
- replay semantics
- rollback eligibility


===============================================================================
22. MINIMAL AUDIT BUNDLE (MAB) — CORE DEFINITION (LOCKED)
===============================================================================

A Minimal Audit Bundle (MAB) is a non-authoritative export artifact intended
to support audit, explanation, and offline inspection.

Purpose:
- capture sufficient evidence to explain what happened and why
- allow external or offline audit
- preserve causal structure without requiring full state

A MAB is NOT:
- authoritative state
- a snapshot
- replayable
- sufficient for restoration


===============================================================================
23. MAB CONTENTS (LOCKED)
===============================================================================

A Minimal Audit Bundle MUST include:
- one or more trace DAGs
- all trace events referenced by those DAGs
- trace metadata required to interpret reason codes
- enough metadata to correlate trace events to:
    - AppInstance identity
    - session identity
    - Orchestration Unit
    - snapshot identity (if any)

A Minimal Audit Bundle MAY include:
- selected journal entries referenced by trace events
- selected committed state excerpts (read-only)
- revision metadata without value payloads

A Minimal Audit Bundle MUST NOT require:
- infinite history
- journal completeness
- state replayability
- mutation capability
- concurrency-first execution

A Minimal Audit Bundle MUST NOT include:
- authoritative committed state in full
- transactional layers
- uncommitted mutations
- executable code
- capability implementations
- secrets or credentials

If included, journal data in a Minimal Audit Bundle MUST follow journal
retention rules and MAY be incomplete.


===============================================================================
24. MAB INTEGRITY & LOSS MODEL (LOCKED)
===============================================================================

Integrity guarantees:
- A MAB MUST preserve trace DAG structure exactly.
- Trace parent-child relationships MUST NOT be altered.
- Missing data MUST be explicitly marked.

Loss tolerance:
- A MAB MAY be incomplete.
- Incompleteness MUST be explicit and trace-visible.
- Absence of data MUST NOT imply absence of behavior.

A MAB MUST be safe to share for audit purposes under applicable policy.


===============================================================================
25. MAB AND JOURNAL INTERACTION (LOCKED)
===============================================================================

Journal entries included in a MAB are evidence only.

Rules:
- Journal inclusion is OPTIONAL.
- Journal absence MUST NOT invalidate the MAB.
- Journal entries included MUST retain original retention class metadata.

Journal entries in a MAB:
- MUST NOT be treated as authoritative state
- MUST NOT be used for replay or mutation
- MAY be truncated or redacted per policy


===============================================================================
26. MAB AND MEMORY STATE (LOCKED)
===============================================================================

State excerpts in a MAB:
- MUST be explicitly labeled as non-authoritative
- MUST be read-only
- MUST include revision identifiers

State excerpts:
- MAY omit historical revisions
- MAY omit unrelated keys
- MUST NOT imply completeness

A MAB MUST NOT be used to mutate or restore state.


===============================================================================
27. MAB CREATION SEMANTICS (LOCKED)
===============================================================================

MAB creation:
- MAY occur while Turnix is running
- MUST NOT pause execution by default
- MUST NOT block orchestration

MAB creation MUST:
- operate on committed data only
- tolerate concurrent activity
- record any omission caused by pressure or policy

MAB creation failure:
- MUST emit trace events
- MUST NOT affect runtime state


===============================================================================
28. MAB NON-GOALS (LOCKED)
===============================================================================

A Minimal Audit Bundle explicitly does NOT provide:

- determinism guarantees
- replay capability
- state restoration
- debugging time travel
- completeness guarantees

Any tooling requiring those properties MUST use snapshots or other
authoritative mechanisms defined elsewhere.


===============================================================================
29. RELATION TO SNAPSHOTS (LOCKED)
===============================================================================

A MAB and a snapshot serve distinct purposes.

Rules:
- A snapshot captures authoritative committed state.
- A MAB captures explanatory evidence.
- A snapshot MAY include traces.
- A snapshot MUST NOT depend on MAB semantics.

A MAB MUST NOT be treated as a lightweight snapshot.


===============================================================================
30. WHAT IS EXPLICITLY NOT REQUIRED
===============================================================================

Turnix does NOT require:
- infinite history
- journal-backed replay
- journal-backed determinism
- journal-backed recovery
- concurrency-first execution
- audit completeness guarantees


===============================================================================
31. CROSS-SESSION AUDIT WORKFLOWS (OPEN)
===============================================================================

Audit workflows operate across:
- traces
- committed state
- revisions
- journal entries

Audit MAY support:
- reconstructing decision chains
- inspecting state evolution over time
- correlating journal evidence with trace events

Audit workflows MUST NOT:
- mutate state
- require journal completeness
- assume replayability


===============================================================================
32. LOCKED SUMMARY
===============================================================================

LOCKED:
- layered memory model
- transactional staging
- deterministic commit / abort
- nested transaction stacking
- commit conflict detection
- single-lane AppInstance orchestration
- persistence as protection, not truth
- journal as best-effort evidence
- inspector-bound transactional mutation
- trace DAG as causal authority
- minimal audit bundle semantics

OPEN:
- snapshot formats
- export serialization formats
- audit tooling UX


===============================================================================
END OF DESIGN AREA 15
===============================================================================

--- doc-meta ---
docId: docs/design/15 MEMORY, STATE, LAYERS & JOURNALING.txt
rev: 2
git: 1476cb3
---------------
