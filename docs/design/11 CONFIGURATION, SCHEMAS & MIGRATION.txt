======================================================================
DESIGN AREA 11 — CONFIGURATION, SCHEMAS & MIGRATION
======================================================================

Status:
-------
CORE — this area defines *how configuration exists*, *how it is validated*,
*how it evolves over time*, and *how user state is protected*.

Configuration is data with identity.
Breaking it silently is forbidden.


----------------------------------------------------------------------
1. CORE CONCEPT
----------------------------------------------------------------------

Configuration answers:

    “What parameters influence Turnix and packs at runtime,
     and how are they made safe, stable, and evolvable?”

Configuration is NOT:
- arbitrary JSON blobs
- free-form user data
- implicit defaults hidden in code


----------------------------------------------------------------------
2. CONFIGURATION TYPES (LOCKED)
----------------------------------------------------------------------

Turnix distinguishes:

A) Global engine config
B) Pack config
C) Save-bound config

Each has:
- schema
- defaults
- user overrides
- migration path


----------------------------------------------------------------------
3. CONFIG SCHEMAS (LOCKED)
----------------------------------------------------------------------

Schemas define:
- structure
- types
- constraints
- defaults (logical, not materialized)

Format:
- JSON Schema–like (exact dialect already implemented)

Location:
- config/**/*.schema.json (inside pack)

Rules:
- schemas are immutable once released
- new versions extend, not rewrite
- breaking change requires new major semver


----------------------------------------------------------------------
4. DEFAULT CONFIGS (LOCKED)
----------------------------------------------------------------------

Defaults:
- provided by pack
- versioned alongside schema
- applied only if user value missing

Formats:
- *.defaults.json
- *.defaults.json5

Defaults are NOT user config.
They are inputs to materialization.


----------------------------------------------------------------------
5. USERDATA CONFIG (LOCKED)
----------------------------------------------------------------------

User overrides live in:
    userdata/config/<canonicalPackId>.json

CanonicalPackId:
- derived during indexing
- uses resolved author + packTreeId
- semver NOT included

Rules:
- loaded after defaults
- overrides defaults only
- never modified silently


----------------------------------------------------------------------
6. CONFIG MATERIALIZATION (LOCKED)
----------------------------------------------------------------------

Effective config is built by:

1) load schema
2) load defaults
3) load userdata override
4) migrate (if needed)
5) validate
6) produce effective config object

If migration or validation fails:
- user-decidable error
- UI must offer repair/reset/restore options


----------------------------------------------------------------------
7. CONFIG ACCESS (LOCKED)
----------------------------------------------------------------------

Packs access config via:
    ctx.config.get(...)
    ctx.config.watch(...)

Direct file access is forbidden.

Config is read-only unless explicitly updated via IoManager.


----------------------------------------------------------------------
8. I/O AUTHORITY BRIDGE (LOCKED)
----------------------------------------------------------------------

ConfigService and all config providers are NOT allowed to do filesystem I/O.

They MUST request reads/writes from IoManager, which enforces:
- permissions and root boundaries
- atomic write behavior
- backup/snapshot policy
- error classification
- UI-mediated recovery flows


----------------------------------------------------------------------
9. CONFIG MIGRATION (LOCKED)
----------------------------------------------------------------------

Migrators:
- ConfigMigrator
- versioned
- ordered

Rules:
- migration runs BEFORE validation
- migrators are pure functions (input document -> output document)
- multiple migrators may run sequentially
- old configs are never discarded without consent


----------------------------------------------------------------------
10. MIGRATION + BACKUP SAFETY (LOCKED POLICY)
----------------------------------------------------------------------

Before writing a migrated config, IoManager SHOULD:
- create a backup of the last known good file (policy-driven)
- write the migrated file atomically
- preserve the previous file for restore if the user chooses

No silent fallback is allowed.
If the config is corrupt or incompatible, the user must be offered:
- restore last known good
- reset to defaults
- quarantine/rename broken config
- abort startup of the affected pack/appInstance (where appropriate)


----------------------------------------------------------------------
11. MANIFEST VS CONFIG MIGRATION (LOCKED DISTINCTION)
----------------------------------------------------------------------

ManifestMigrator:
- evolves pack metadata

ConfigMigrator:
- evolves user state

They are separate and must remain so.


----------------------------------------------------------------------
12. SAVE-BOUND CONFIG (LOCKED)
----------------------------------------------------------------------

Save-specific config:
- stored under saves/<appPackId>/<appInstanceId>/
- overrides global config
- migrates independently

Deletion or corruption of save config:
- does not affect global config


----------------------------------------------------------------------
13. ERROR HANDLING (LOCKED)
----------------------------------------------------------------------

Config errors are classified as:

Fatal:
- schema missing
- defaults missing
- failures before minimal UI is ready

Recoverable (user-decidable):
- invalid user value
- parse errors in userdata config
- outdated version requiring migration
- restore-from-backup decisions

Recovery must be UI-driven.


----------------------------------------------------------------------
14. DEV-MODE DIAGNOSTICS (LOCKED)
----------------------------------------------------------------------

In development:
- report unused config keys
- report deprecated keys
- report schema drift

Non-fatal, informational only.


----------------------------------------------------------------------
15. NO IMPLICIT FALLBACKS (LOCKED)
----------------------------------------------------------------------

Turnix MUST NOT:
- invent defaults silently
- ignore invalid config
- auto-reset without user consent
- silently treat parse errors as "empty config"

Explicitness over convenience.


----------------------------------------------------------------------
16. OPEN QUESTIONS
----------------------------------------------------------------------

OPEN:
- config hot-reload semantics
- config diff UI
- partial save-bound inheritance


----------------------------------------------------------------------
17. LOCKED SUMMARY
----------------------------------------------------------------------

LOCKED:
- schema-driven config
- defaults + overrides
- canonical config identity (author + packTreeId; no semver)
- explicit migration (pure functions)
- IoManager-mediated I/O only (no filesystem I/O in ConfigService/providers)
- UI-mediated recovery
- backup/restore options for user-decidable config failures

OPEN:
- tooling & UX enhancements only


----------------------------------------------------------------------
END OF DESIGN AREA 11
----------------------------------------------------------------------

