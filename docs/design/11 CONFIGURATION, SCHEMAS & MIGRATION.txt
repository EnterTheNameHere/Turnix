===============================================================================
DESIGN AREA 11 - CONFIGURATION, SCHEMAS & MIGRATION
===============================================================================

Status:
-------
CORE - this area defines how configuration exists, how it is validated,
how it evolves over time, and how user state is protected.

Configuration is data with identity.
Breaking it silently is forbidden.


===============================================================================
1. CORE CONCEPT
===============================================================================

Configuration answers:

    "What parameters influence Turnix and packs at runtime,
     and how are they made safe, stable, and evolvable?"

Configuration is NOT:
- arbitrary JSON blobs
- free-form user data
- implicit defaults hidden in code


===============================================================================
2. CONFIGURATION TYPES & SCOPES (LOCKED)
===============================================================================

Turnix distinguishes configuration by SCOPE:

A) Engine (kernel-global)
B) Pack-global
C) Save-bound (pack-local)

Each scope has:
- schema
- defaults
- user overrides
- migration path

Scopes are strictly ordered by precedence:
Save-bound > Pack-global > Engine > Defaults

Ownership:
- Engine scope is owned by the kernel
- Pack-global and Save-bound scopes are owned by a specific canonicalPackId
- Ownership is immutable without migration

This ownership model is normative and constrained further by:
- OE - CROSS-PACK PERMISSIONS - STATE ACCESS, MUTATION & AUTHORITY


===============================================================================
3. CONFIG SCHEMAS (LOCKED)
===============================================================================

Schemas define:
- structure
- types
- constraints
- allowed value shapes
- access-level metadata (see OE)

Schemas MUST NOT be relied upon as a source of defaults.

Format:
- JSON Schema-like (exact dialect already implemented)

Locations (first-found-wins within root priority):
- <root>/config/schema/**/*.schema.json
- <root>/<pack>/config/schema/**/*.schema.json

Rules:
- schemas are immutable once released
- new versions extend, not rewrite
- breaking change requires new major semver
- access level metadata is immutable without migration


===============================================================================
4. DEFAULT CONFIGS (LOCKED)
===============================================================================

Defaults define initial values only.

Defaults:
- are provided by kernel or packs
- are versioned alongside schema
- are applied only if user override is missing
- MUST NEVER be overwritten

Formats:
- *.defaults.json
- *.defaults.json5

Locations:
- <root>/config/defaults/
- <root>/<pack>/config/defaults/

Defaults are NOT user config.
Defaults are NOT mutable state.
Defaults may change between pack versions at author responsibility.


===============================================================================
5. USER OVERRIDES (LOCKED)
===============================================================================

User overrides store only deviations from defaults.

Locations:

Engine (kernel-global):
    userdata/config/engine/*.json5

Pack-global:
    userdata/config/packs/<canonicalPackId>/*.json5

Save-bound (pack-local):
    saves/<appPackId>/<appInstanceId>/config/packs/<canonicalPackId>/*.json5

CanonicalPackId:
- resolved author + packTreeId
- semver NOT included

Rules:
- overrides never modify defaults
- overrides are loaded after defaults
- overrides are migrated explicitly
- overrides are never modified silently
- overrides are the ONLY writable layer


===============================================================================
6. CONFIG MATERIALIZATION PIPELINE (LOCKED)
===============================================================================

Configuration is resolved in ordered layers:

1) schema
2) defaults
3) user overrides (engine / pack-global / save-bound)
4) migration (if required)
5) validation of stored values
6) computed transforms (if any)
7) effectiveConfig materialization

Only steps 1-5 are gating.
Steps 6-7 MUST NOT block persistence.

Computed layers are constrained by OE and MUST NOT alter stored state.


===============================================================================
7. EFFECTIVE CONFIG & COMPUTED TRANSFORMS (LOCKED)
===============================================================================

Some configuration values may be:
- computed
- derived
- transformed
- adjusted based on other values

Rules:
- computed transforms MUST NOT mutate stored values
- computed transforms MUST NOT write to config
- computed transforms operate only on effectiveConfig
- removal of a transform MUST restore prior behavior
- computed layers must be traceable

EffectiveConfig represents the final, runtime-visible values only.


===============================================================================
8. DIAGNOSTIC VALIDATION OF EFFECTIVE CONFIG (LOCKED, NON-BLOCKING)
===============================================================================

Turnix MAY validate effectiveConfig against schema
for diagnostic purposes only.

Diagnostic validation:
- MUST NOT block set(), save(), or load
- MUST NOT rewrite stored config
- MUST emit trace reasons when violated
- MUST be surfaced to the user as informational warnings

Example trace reason:
- EffectiveConfigValidationFailed

Stored config validation remains authoritative.


===============================================================================
9. CONFIG ACCESS API (LOCKED)
===============================================================================

Configuration access is scope-explicit and ownership-aware.

Engine scope:
    config.engine.get(key)
    config.engine.set(key, value)
    config.engine.delete(key)

Pack-global scope:
    config.user.get(packSelector, key)
    config.user.set(packSelector, key, value)
    config.user.delete(packSelector, key)

Save-bound scope:
    config.save.get(key)
    config.save.set(key, value)
    config.save.delete(key)

Read semantics:
- get() returns value or raises NotFoundOrPermissionDenied
- tryGet() MAY return None instead of throwing
- no API distinguishes "not found" from "permission denied"

Write semantics:
- writes always target an explicit owner scope
- writes may trigger permission decisions (see OE, DA-14)
- delete() removes overrides only (never defaults)
- deletion of subtrees MUST be supported


===============================================================================
10. I/O AUTHORITY BRIDGE (LOCKED)
===============================================================================

ConfigService and all config providers:
- MUST NOT perform filesystem I/O
- MUST route all persistence through IoManager

IoManager enforces:
- root boundaries
- permissions
- atomic writes
- backup / snapshot policy
- error classification
- UI-mediated recovery


===============================================================================
11. CONFIG MIGRATION (LOCKED)
===============================================================================

Migrators:
- ConfigMigrator
- versioned
- ordered

Rules:
- migration runs BEFORE validation
- migrators are pure functions (input -> output)
- multiple migrators may run sequentially
- migration may inspect previous values
- migration MUST NOT discard user intent silently
- migration MUST preserve ownership and access metadata


===============================================================================
12. MIGRATION + BACKUP SAFETY (LOCKED)
===============================================================================

Before writing migrated config, IoManager SHOULD:
- snapshot the last known good version
- write atomically
- retain rollback capability

User MUST be offered:
- restore last known good
- reset to defaults
- quarantine broken config
- abort affected startup

No silent fallback is allowed.


===============================================================================
13. MANIFEST VS CONFIG MIGRATION (LOCKED DISTINCTION)
===============================================================================

ManifestMigrator:
- evolves pack metadata

ConfigMigrator:
- evolves user state

They are separate and must remain so.


===============================================================================
14. SAVE-BOUND CONFIG (LOCKED)
===============================================================================

Save-bound config:
- is isolated per save
- overrides pack-global and engine values
- migrates independently
- is included in SavePack snapshots

Corruption or deletion:
- does NOT affect global config


===============================================================================
15. ERROR HANDLING (LOCKED)
===============================================================================

Config errors are classified as:

Fatal:
- missing schema
- missing defaults
- failure before minimal UI is ready

Recoverable (user-decidable):
- invalid user value
- parse errors
- migration-required state
- restore-from-backup decisions

Recovery MUST be UI-driven.


===============================================================================
16. DEV-MODE DIAGNOSTICS (LOCKED)
===============================================================================

In development:
- report unused keys
- report deprecated keys
- report schema drift
- report effective-config diagnostics
- report access denials (informational)

All diagnostics are non-fatal.


===============================================================================
17. NO IMPLICIT FALLBACKS (LOCKED)
===============================================================================

Turnix MUST NOT:
- invent defaults
- ignore invalid stored values
- auto-reset without consent
- treat parse errors as empty config

Explicitness over convenience.


===============================================================================
18. OPEN QUESTIONS
===============================================================================

OPEN:
- hot-reload semantics
- config diff UI
- cross-scope promotion UX


===============================================================================
19. LOCKED SUMMARY
===============================================================================

LOCKED:
- per-scope configuration stores
- explicit ownership per scope
- schema-declared access metadata
- defaults are immutable
- overrides only record deviations
- explicit migration
- diagnostic-only effective validation
- IoManager-mediated persistence
- UI-mediated recovery
- NotFoundOrPermissionDenied read semantics

OPEN:
- UX and tooling only


===============================================================================
END OF DESIGN AREA 11 - CONFIGURATION, SCHEMAS & MIGRATION
===============================================================================


--- doc-meta ---
docId: docs/design/11 CONFIGURATION, SCHEMAS & MIGRATION.txt
rev: 5
git: d1b3b4b
----------------
