======================================================================
DESIGN AREA 1 — PROJECT INVARIANTS & PHILOSOPHY
======================================================================

Status:
-------
FOUNDATIONAL — applies to all other areas.
Changes here have cascading impact and must be rare and explicit.

Purpose:
--------
This document captures the non-negotiable principles that guide Turnix
design decisions. These are not implementation details, but constraints
that shape *how* solutions are evaluated and *why* certain approaches
are rejected even if they are simpler.

This area exists to prevent:
- silent behavior changes
- implicit magic
- accidental server-style assumptions
- erosion of determinism through convenience shortcuts


----------------------------------------------------------------------
1. CORE GOAL
----------------------------------------------------------------------

Turnix exists to enable a *persistent, local, identity-stable system*
built on modular packs, without relying on server infrastructure or
stateless execution assumptions.

Turnix is NOT:
- a plugin loader
- a dynamic script runner
- a web app framework
- a convenience-first modding system

Turnix IS:
- a continuity engine
- a deterministic resolver
- a policy-driven orchestrator
- an explainable system


----------------------------------------------------------------------
2. LOCKED INVARIANTS (NON-NEGOTIABLE)
----------------------------------------------------------------------

The following principles are LOCKED and must be assumed everywhere.

----------------------------------------------------------------------
2.1 Determinism over convenience
----------------------------------------------------------------------

- Given the same filesystem, config, and user decisions:
  → Turnix must make the same choices every time.
- No silent substitution.
- No implicit “best guess” resolution.

If ambiguity exists:
- classify it
- explain it
- resolve it via policy or user decision
- persist the outcome

----------------------------------------------------------------------
2.2 Continuity over performance
----------------------------------------------------------------------

- Persistence failures are existential, not cosmetic.
- Partial writes to required state are forbidden.
- Quarantine is preferred over overwrite.
- “Best effort” is acceptable ONLY for explicitly optional data
  (logs, traces, analytics).

----------------------------------------------------------------------
2.3 Explicitness over magic
----------------------------------------------------------------------

- No hidden imports.
- No invisible dependency resolution.
- No behavior that cannot be explained post-factum.

If something works, it must be explainable *why*.
If something fails, it must be explainable *why*.

----------------------------------------------------------------------
2.4 User-visible decisions
----------------------------------------------------------------------

- Any decision that could reasonably surprise a user must be surfaced.
- If a user is asked once, the decision is persisted.
- Silent retries or fallbacks are forbidden unless explicitly policy-driven.

----------------------------------------------------------------------
2.5 Local-first assumption
----------------------------------------------------------------------

- Turnix assumes:
  - local filesystem
  - limited hardware
  - limited context window
- Server-scale patterns (lazy global registries, infinite retries,
  implicit availability) are rejected by default.

----------------------------------------------------------------------
2.6 No guarantees outside orchestration
----------------------------------------------------------------------

LOCKED STATEMENT:

"Turnix does not guarantee behavior for background work started outside
Turnix orchestration; only work triggered by Turnix entrypoints or
capability calls is supported."

This applies to:
- timers
- background threads
- ad-hoc async tasks
- side-effect-only module execution

If a pack does this anyway, consequences are on the author.


----------------------------------------------------------------------
3. AGREED DESIGN ATTITUDE (ADJUSTABLE)
----------------------------------------------------------------------

These are strong preferences, but may evolve with experience.

----------------------------------------------------------------------
3.1 Explainability beats elegance
----------------------------------------------------------------------

A slightly verbose system that can explain itself is preferred over
a clever system that “just works”.

----------------------------------------------------------------------
3.2 Policy before prohibition
----------------------------------------------------------------------

When possible:
- classify behavior
- gate it by policy
- make defaults conservative

Instead of:
- blanket forbidding
- silent allowance

----------------------------------------------------------------------
3.3 Tooling friendliness
----------------------------------------------------------------------

Design should enable:
- trace inspection
- pack manager UI
- conflict explanation
- replay of decisions

Even if tooling is not implemented yet.


----------------------------------------------------------------------
4. EXPLICITLY OPEN QUESTIONS
----------------------------------------------------------------------

These are NOT decided yet and must remain visible as open.

----------------------------------------------------------------------
4.1 How much autonomy can packs have?
----------------------------------------------------------------------

Open:
- Should packs ever be allowed to declare “always allow” permissions?
- Should packs be able to auto-activate toolchains?

----------------------------------------------------------------------
4.2 How much AI assistance is appropriate?
----------------------------------------------------------------------

Open:
- Can LLM-assisted error recovery exist?
- If yes, at which lifecycle phase?
- Is it optional, policy-gated, or first-class?

----------------------------------------------------------------------
4.3 How strict is “local-first” long term?
----------------------------------------------------------------------

Open:
- Remote assets?
- Remote compilers?
- Federated pack indexes?

All currently out of scope, but not philosophically banned.


----------------------------------------------------------------------
5. WHY THIS AREA EXISTS
----------------------------------------------------------------------

Without this area, later specs risk drifting into:
- convenience-driven shortcuts
- accidental server assumptions
- silent failure tolerance
- “we’ll fix it later” logic

This document is the anchor that prevents that drift.


----------------------------------------------------------------------
END OF DESIGN AREA 1
----------------------------------------------------------------------

