===============================================================================
DESIGN AREA 15 - MEMORY, STATE, LAYERS & JOURNALING
===============================================================================

Status:
-------
CORE - this area defines how runtime state exists, how it is layered,
how mutations are staged and committed, how persistence is handled,
and how historical evidence is recorded without compromising determinism
or safety.

Purpose and Scope:
------------------
This design area defines the authoritative model for runtime memory, state,
and historical evidence in Turnix.

It defines:
- what "memory" means in Turnix
- what "state" means in Turnix
- how runtime state is layered
- how mutations are staged and committed
- how persistence relates to runtime memory
- how rollback and reproducibility are achieved
- how historical evidence is recorded without becoming authoritative
- what is considered authoritative vs observational
- what a Trace Directed Acyclic Graph (trace DAG) is
- what Windows represent and why they exist
- what SafePointWindow, ActiveWindow, and AbortedWindow mean
- how WindowManifests relate to finalized Windows
- how exports relate to finalized Windows
- what a Minimal Audit Bundle (MAB) is and what it is not
- what Replay, Resume, and Retry mean in Turnix
- the storage-neutral payload model used by committed state, savePacks,
  traces, journals, windows, manifests, and exports
- how offline comparison operates and what results it may produce

It does NOT define:
- user interface layout or presentation rules for memory tooling
- concrete file formats for manifests, exports, traces, journals, or chunks
  beyond LOCKED semantic contracts
- specific digest algorithms, canonical serialization rules, or codec formats
  beyond LOCKED constraints
- concurrency-first execution; this area assumes deterministic single-lane
  execution unless explicitly enabled elsewhere
- lifecycle rules for documents (see creation and change rules)


===============================================================================
01. CORE INTENT
===============================================================================

This design area defines the semantic contract for all memory- and 
state-related behavior in Turnix.

Turnix MUST:
- preserve deterministic state evolution
- make all authoritative state transitions explicit
- support rollback and reproducibility
- support inspection, explanation, and audit
- separate authority from observation
- avoid unbounded growth by policy-driven retention
- avoid silent data loss

Turnix MUST NOT:
- conflate state with logs, traces, or journals
- treat observational data as authoritative
- require infinite history retention
- depend on journal completeness for correctness
- make silent pruning or reconciliation decisions
- imply determinism where it does not exist

This design area establishes the hard boundary between:
- authoritative committed state
- non-authoritative runtime activity
- non-authoritative historical evidence

All other sections in this design area elaborate on this boundary.


===============================================================================
02. TERMS AND AUTHORITY BOUNDARIES
===============================================================================

This section defines core terminology and the authority boundaries that govern
memory, state, and historical material in Turnix.

These definitions are LOCKED and apply uniformly across all subsystems.


02.1 Memory vs State
--------------------

Memory:
- is the runtime representation of values
- may exist only in-process
- may include speculative, staged, or transient data
- is mutable
- is not inherently authoritative

State:
- is the authoritative outcome of committed memory
- exists independently of runtime residency
- is the source of truth for restoration and comparison
- is immutable once committed, except through new revisions

Rules (LOCKED):
- Memory MAY exist without persistence.
- Persistence MAY exist without memory being resident.
- Only committed state is authoritative.
- Runtime memory MUST NOT be treated as authoritative unless committed.


02.2 Authority Classes
----------------------

Turnix distinguishes between authoritative and non-authoritative material.

Authority classes (LOCKED):

A) Authoritative
- committed memory layers
- committed configuration
- state captured by a SafePointWindow

Authoritative material:
- defines the current truth of the system
- is sufficient to restore system state deterministically
- is required for correctness

B) Non-authoritative
- transactional staging layers
- uncommitted runtime memory
- trace contents
- journal contents
- Minimal Audit Bundles (MAB)
- ActiveWindow contents and metadata
- evidence roots attached to WindowManifests

Non-authoritative material:
- MAY be used for explanation, audit, or debugging
- MUST NOT be required for state correctness
- MUST NOT affect restoration or equality checks
- MAY be incomplete, truncated, or missing by policy


02.3 Authority Separation Rules
-------------------------------

Rules (LOCKED):
- Authoritative state MUST be derivable without access to:
  - journals
  - traces
  - transactional layers
  - debugger artifacts
- Non-authoritative material MUST NOT be required to:
  - restore committed state
  - evaluate StateEquality
  - validate correctness of committed values
- Loss of non-authoritative material MUST NOT:
  - corrupt committed state
  - change committed meaning
  - invalidate determinism guarantees

This separation ensures that:
- correctness does not depend on observation
- audit does not become a hidden dependency
- safety is preserved under retention pressure
- rollback remains reliable


===============================================================================
03. STORAGE-NEUTRAL PAYLOAD MODEL
===============================================================================

This section defines how committed state, savePacks, traces, journals,
windows, manifests, and exports reference immutable payload data without
assuming a specific storage backend.

This model is LOCKED at the semantic level.


03.1 Core Idea
--------------

Authoritative committed state does not embed mutable runtime objects.

Instead:
- committed state references immutable payload bytes
- runtime objects are decoded views of immutable payloads
- persistence format is storage-neutral

This allows:
- deterministic restoration
- safe sharing of payloads
- offline inspection
- backend-agnostic storage implementations


03.2 Core Terms
---------------

Chunk:
- an immutable byte sequence
- addressed by a ChunkId

ValueRef:
- an immutable reference describing how to obtain and decode a value payload

Codec:
- a deterministic decoding rule
- identified by codecId

Schema:
- optional typing and version metadata
- used for typed decoding and migration

Root manifest:
- an immutable manifest
- enumerates references (ChunkId, ValueRef)
- defines a reachability root for garbage collection


03.3 Payload Rules
------------------

Rules (LOCKED):
- A committed key in a committed layer or committed configuration MUST be
  representable as:

      key -> ValueRef

  at the SafePointWindow boundary.

- A ValueRef MUST be immutable once created.

- A ValueRef MUST NOT depend on:
  - transactional layers
  - journal completeness
  - trace completeness
  - external side effects
  in order to decode successfully.

- If a ValueRef cannot be decoded:
  - the failure MUST be explicit
  - the value MUST NOT be treated as authoritative

- A live runtime object, if resident, is the decoded form of a ValueRef.
  Runtime residency is an implementation detail and MUST NOT change meaning.


03.4 Value Origin and Static Data
---------------------------------

Static data is pack-provided or bundled resource data.

Rules (LOCKED):
- A ValueRef MAY reference payload bytes originating from static data.
- If committed state stores a value derived from static data, it MUST still be
  representable as a ValueRef at the SafePointWindow boundary.
- "Patch" and "Copy" semantics apply at the value-meaning level, not at the
  chunk storage level.
- Chunk reuse or duplication is an implementation detail as long as
  the ValueRef meaning is preserved.


03.5 IoManager Boundary
-----------------------

All persistence required to resolve ValueRefs and Chunks is mediated by
IoManager (Design Area 10).

Rules (LOCKED):
- Packs MUST NOT resolve chunk storage directly.
- Packs MUST NOT write payload bytes referenced by ValueRefs directly.
- Readers and Writers that implement chunk storage or codecs operate under
  IoManager authority and are subject to DA-10 restrictions.


03.6 Payload Sharing Across Artifacts
-------------------------------------

Payload chunks MAY be shared across artifacts.

Meaning:
- the same ChunkId MAY be referenced by multiple windows, manifests, traces,
  journals, Minimal Audit Bundles, and exports.

Rules (LOCKED):
- Payload sharing MUST NOT change authority boundaries.
- Sharing MUST be safe under reachability-based garbage collection.
- Sharing inside a savePack MUST NOT weaken immutability guarantees.
- If an export claims immutability, it MUST be self-contained with respect to
  retained payloads, subject to explicit partial-export policy.


===============================================================================
04. CHUNK IDENTITY CONTRACT
===============================================================================

This section defines the minimum, storage-agnostic contract for identifying
immutable payload data referenced by savePacks, windows, traces, journals,
manifests, and exports.

This contract is LOCKED at the semantic level.
Encoding details remain OPEN within stated constraints.


04.1 Purpose
------------

The Chunk Identity Contract exists to:
- provide stable identity for immutable payload data
- enable integrity verification
- support reachability-based garbage collection
- allow export, import, and copying between storage backends
- avoid assumptions about filesystem layout or databases

This contract does NOT define:
- physical storage layout
- file formats
- compression or encryption mechanisms
- network transport
- persistence policy


04.2 Chunk Definition
---------------------

A Chunk is an immutable byte sequence.

Rules (LOCKED):
- A Chunk MUST be immutable once created.
- Chunk immutability MUST be enforced by the storage implementation.
- A Chunk MUST be addressable by a stable ChunkId.
- A Chunk MUST be retrievable given its ChunkId, unless it has been removed
  by explicit garbage-collection policy.


04.3 Chunk Identity
-------------------

A ChunkId is the canonical identity of a Chunk.

Rules (LOCKED):
- Two Chunks are the same Chunk if and only if their ChunkId is identical.
- ChunkId MUST be stable across:
  - export and import
  - copying between storage backends
  - savePack repackaging

ChunkId MUST NOT depend on:
- filesystem paths
- database row identifiers
- local timestamps
- machine identity
- wall-clock time


04.4 Content Addressing Requirement
-----------------------------------

ChunkId MUST be content-derived.

Meaning:
- ChunkId is computed from the chunk's payload bytes and declared identity
  metadata.

Rules (LOCKED):
- ChunkId MUST be derived from:
  A) the payload byte sequence
  B) the chunk metadata fields that participate in identity
- ChunkId MUST NOT be derived from values expected to differ across
  machines or runs, including:
  - absolute paths
  - hostnames
  - random identifiers
  - wall-clock time


04.5 Required Chunk Metadata
----------------------------

Each Chunk MUST have an associated ChunkHeader.

ChunkHeader fields:
- chunkId
- chunkType
- byteLength
- hashAlgorithm
- contentHash

Rules (LOCKED):
- byteLength MUST equal the number of bytes in the payload.
- contentHash MUST be computed over the payload bytes.
- hashAlgorithm MUST name a deterministic hash function.
- chunkType MUST be a stable, explicit identifier.
- chunkType MUST NOT change the meaning of chunk identity.

Example chunkType values (non-exhaustive):
- stateLayerValues
- configValues
- revisionIndex
- journalEntries
- traceEvents
- traceIndex
- windowManifest
- packManifest
- blob


04.6 Integrity Verification
--------------------------

Integrity check procedure:
- recompute contentHash from payload bytes
- compare with stored contentHash

Rules (LOCKED):
- Storage MUST reject retrieval as corrupt if integrity verification fails.
- Corruption MUST be trace-visible when detected.
- Corrupt data MUST NOT be treated as authoritative.
- ChunkId MUST be verified to match the identity-relevant header fields.


04.7 ChunkId Encoding
---------------------

The exact encoding of ChunkId is OPEN, but constrained.

Rules (LOCKED):
- ChunkId MUST be representable in plain text.
- ChunkId MUST be stable byte-for-byte across export and import.
- ChunkId MUST avoid characters disallowed by Turnix document style
  when printed in specifications or manifests.

Permitted encoding examples (illustrative only):
- hash-based hexadecimal
- hash-based base32 or base64url without padding
- explicit "algorithm:hash" forms


04.8 Format Awareness and Versioning
------------------------------------

Chunk identity MUST be format-aware.

Meaning:
- payloads representing the same semantic value in different encodings MUST
  produce different ChunkIds.

Rules (LOCKED):
- Any change to payload serialization format MUST result in a new ChunkId.
- chunkType MAY include a schemaId or formatId as part of header metadata.


04.9 Reachability and Garbage Collection Support
------------------------------------------------

Reachability is defined by explicit root manifests.

Rules (LOCKED):
- All chunk references MUST be by ChunkId.
- Storage MUST allow enumeration of chunk references starting from a root
  manifest sufficient to compute reachability.
- Garbage collection MAY delete chunks unreachable from all roots, subject to
  explicit policy.
- Garbage collection MUST NOT delete any chunk reachable from an authoritative
  root.
- Garbage collection MUST NOT occur silently; actions MUST be trace-visible.

Example roots (non-exhaustive):
- savePack manifests
- pinned WindowManifests
- pinned Minimal Audit Bundle manifests
- other explicitly designated policy roots


04.10 Optional Chunk Capabilities
---------------------------------

Optional features MAY be supported by storage backends:
- compression
- encryption at rest
- chunk streaming
- logical chunk packing into containers
- partial retrieval via index chunks

Rules (LOCKED):
- Optional capabilities MUST NOT change chunk identity semantics.
- If storage transforms bytes (compression, encryption), ChunkId MUST be
  computed over canonical payload bytes, OR the canonical rule MUST be
  explicitly redefined in the storage specification.
- Paging and partial retrieval MUST be expressed through chunks and index
  chunks and MUST NOT introduce hidden references outside reachability.


===============================================================================
05. VALUEREF (LOCKED)
===============================================================================

A ValueRef is an immutable reference to a value payload used by committed
layers and committed config.

A ValueRef is NOT a pointer to live runtime memory.
A ValueRef is a deterministic decoding contract for a specific payload.

Rules (LOCKED):
- A committed key in a committed layer or committed config MUST be
  representable as (key -> ValueRef) at the SafePointWindow boundary.
- A ValueRef MUST be immutable once created.
- A ValueRef MUST NOT require transactional layers, journal completeness, or
  external side effects to decode.
- If a ValueRef cannot be decoded, the failure MUST be explicit.

A ValueRef MAY be resolved eagerly (value is resident) or lazily (value is not
resident). This is an implementation choice and MUST NOT change semantics.


05.1 ValueRef Forms
-------------------

A ValueRef is exactly one of the following forms:

A) InlineValueRef
- payload bytes are stored directly inside the ValueRef

B) ChunkValueRef
- payload bytes are stored in a Chunk and referenced by ChunkId

Rules (LOCKED):
- Both forms MUST include an explicit codec identifier.
- ChunkValueRef MUST include integrity metadata sufficient to validate
  retrieved payload bytes.
- InlineValueRef MAY include integrity metadata.
- External references (network, arbitrary file path) are not part of ValueRef
  unless explicitly introduced later. If introduced later, they MUST NOT be
  used for authoritative committed state unless deterministic retrieval is
  guaranteed.


05.2 ValueRef Required Fields
-----------------------------

All ValueRef forms MUST include:
- codecId
  Stable identifier describing how payload bytes decode into a value.

All ChunkValueRef MUST include:
- chunkId
  Stable identity of immutable payload bytes.
- integrity
  Integrity metadata used to validate retrieved payload bytes.

A ValueRef MAY include:
- contentType
  Informational media type. Not required for correctness.
- schemaId and schemaVersion
  Optional schema linkage for typed decoding (Section 05.3).


05.3 Schemaless Default and Optional Schema
-------------------------------------------

Values are schemaless by default.

Schemaless default means:
- a ValueRef without schema fields decodes into a generic runtime structure
  defined by its codec (examples: map, list, scalar, bytes)

Optional schema means:
- a ValueRef MAY include schemaId (and schemaVersion if needed)
- if schema is present, decoding is schema-aware and MAY produce a typed
  runtime object or a typed structure

Rules (LOCKED):
- Presence of schema fields MUST NOT be required for storing simple values.
- If schema fields are present and schema-aware decode fails, failure MUST be
  explicit unless an explicit policy allows fallback to schemaless decode.
- Any fallback behavior MUST be trace-visible.


===============================================================================
06. MEMORY LAYERS (LOCKED)
===============================================================================

Turnix manages memory as a set of layered stores.

Layers represent:
- authority
- scope
- lifetime
- rollback boundaries

Examples of layers include (non-exhaustive):
- kernel-global
- appInstance
- session
- view
- transactional

Rules (LOCKED):
- There is NO single "global memory object".
- Each layer contains real values.
- Reads resolve according to the active layer stack for the requesting scope.

Committed layer contract (LOCKED):
- At a SafePointWindow boundary, a committed memory layer MUST be
  representable as:
      key -> ValueRef
- Layer serialization MUST serialize ValueRefs, not live object identities.


===============================================================================
07. TRANSACTIONS (LOCKED)
===============================================================================

A transaction is a temporary staging overlay used to record speculative
mutations before they become authoritative.

Properties:
- overlays one or more parent layers
- captures all writes during its lifetime
- allows reads from parent layers
- is resolved only by commit or abort

Primary usage:
- pipeline execution
- capability calls with mutation
- debugger-initiated staging


07.1 Commit and Abort
---------------------

Rules (LOCKED):
- A transaction MUST end in exactly one outcome:
  - commit
  - abort
- Partial propagation is forbidden.
- Commit and abort:
  - are atomic
  - are trace-backed
  - preserve rollback guarantees

On commit:
- values propagate to their target authoritative layers or to a parent
  transaction, depending on nesting rules

On abort:
- all staged mutations are discarded deterministically


07.2 Nested Pipeline Runs and Transaction Stacking
--------------------------------------------------

If a pipeline run creates or enters another session (a child session) while an
enclosing pipeline run is active, the child session MUST inherit the enclosing
transactional view.

Effective read/write stack:

    kernel layer
    appInstance layer
    parent session layer
    parent transaction layer (txnParent)
    child transaction layer  (txnChild)

Rules (LOCKED):
- Reads resolve first-match from txnChild downward.
- Writes always target txnChild.
- Committing txnChild propagates its writes into txnParent.
- No child transaction may commit directly into committed layers while an
  enclosing transaction exists.
- Only the outermost transaction commit may mutate committed layers.

This prevents lost updates and desynchronization between pipeline runs.


07.3 Commit into Committed Layers and Conflict Detection
--------------------------------------------------------

Commit conflict detection applies ONLY when a transaction attempts to commit
into committed layers.

Each transaction records, per key, the base revision id visible at the time
the key was first read or first written within that transaction.

When committing into committed layers:
- if the committed layer's latest revision id differs from the recorded base
  revision id, the commit is in conflict and MUST fail deterministically.

Rules (LOCKED):
- No silent merge is allowed.
- No last-write-wins is allowed.
- No heuristic reconciliation is allowed.
- Any override requires explicit user or policy decision (DA-14).

Conflict detection MUST NOT be applied to txnChild -> txnParent propagation.
txnChild -> txnParent propagation is not authoritative mutation.


===============================================================================
08. ORCHESTRATION (LOCKED)
===============================================================================

An Orchestration Unit is a kernel-tracked execution unit that is permitted to
mutate Turnix-managed state within an AppInstance.

Examples (non-exhaustive):
- a pipeline run, including its stage callbacks
- a capability handler invocation
- a debugger-initiated mutation transaction
- config mutation request processing

Work started outside Turnix orchestration is not an Orchestration Unit until
it re-enters through orchestration boundaries.


08.1 Single-Lane AppInstance Orchestration
------------------------------------------

Turnix orchestrates execution in a deterministic single-lane model.

Rules (LOCKED):
- Within a given AppInstance, Turnix MUST NOT execute multiple Orchestration
  Units concurrently.
- Awaited input/output or model calls MAY suspend the current unit, but
  MUST NOT allow another unit that can mutate the same AppInstance state to
  run
  concurrently unless an explicit concurrency mode is enabled by the kernel.
- Work started outside Turnix orchestration is outside Turnix guarantees. Any
  mutation MUST re-enter through orchestration boundaries.


===============================================================================
09. PERSISTENCE MODEL (LOCKED)
===============================================================================

Persistence is protection against loss, not the definition of state.

Rules (LOCKED):
- any committed value MAY be persisted
- persistence is handled exclusively by Turnix
- persistence is asynchronous but ordered
- failure to persist MUST be trace-visible

Persistence does not imply:
- immediate disk residency
- exclusive in-memory presence
- unlimited retention


===============================================================================
10. STATIC DATA AND MUTATION INTENT (LOCKED)
===============================================================================

Static data is data provided by:
- packs
- configuration
- bundled resources

Static data is read-only by default.

When a mutation is attempted on static data, intent MUST be explicit:

A) Patch
- original key remains authoritative
- patch is applied on each read
- patch is persisted as overlay data

B) Copy
- a new key is created
- data is copied and modified
- original remains unchanged

This decision MAY require user interaction (DA-14).


===============================================================================
11. REVISIONS AND STATE GARBAGE COLLECTION (LOCKED)
===============================================================================

Committed state values MAY have revisions.

Revisions exist to support:
- rollback
- auditing
- debugging

Revision retention is policy-driven.

Garbage collection MAY remove:
- old revisions
- unreachable historical states

Garbage collection MUST NOT:
- remove data required to reconstruct current committed state
- occur silently
- violate rollback guarantees

Interaction with payload model (LOCKED):
- Removing a revision MAY make older ValueRefs unreachable.
- Chunk garbage collection MUST obey reachability rules (Section 04.9).
- Revision removal MUST NOT invalidate the ability to restore the latest
  committed state for each committed key.


===============================================================================
12. JOURNAL (LOCKED)
===============================================================================

The journal records observational evidence of system activity.

Journal is:
- append-only
- non-authoritative
- non-blocking
- trace-adjacent

Examples:
- raw user input attempts
- raw assistant output (including aborted streams)
- intermediate pipeline artifacts
- debugging captures

Rules (LOCKED):
- Journal data is NOT state.
- Journal data is NOT required for correctness.


12.1 Journal Retention Model
----------------------------

Journal retention follows a best-effort model.

LOCKED MEANING:
- If retention limits are exceeded (size, age, quota), older journal entries
  MAY be pruned.
- If storage is unavailable or under severe pressure, journal writes MAY be
  dropped rather than blocking execution.
- Any pruning or dropped writes MUST be trace-visible and classified.

Journal loss MUST NOT affect correctness.


12.2 Journal Retention Policies
-------------------------------

Retention policies MAY include:
- maximum total size
- maximum age
- per-appInstance quota
- per-save quota
- per-category quota

Policies are:
- explicit
- inspectable
- configurable

Journal garbage collection:
- occurs incrementally
- emits trace events (what, why, policy)
- MUST NOT block execution


12.3 Journal Retention Classes
------------------------------

Journal entries MAY declare a retention class:

A) ephemeral
- safe to prune aggressively
- streaming chunks, transient outputs

B) bounded
- retained per policy
- suitable for post-mortem analysis

C) pinned
- pruned only by explicit user action
- intended for rare use

Retention class affects garbage collection only.


===============================================================================
13. TRACE DIRECTED ACYCLIC GRAPH (TRACE DAG) (LOCKED)
===============================================================================

Turnix tracing is modeled as a Trace Directed Acyclic Graph (trace DAG).

Definition:
- A trace DAG is a directed acyclic graph of trace events.
- Each trace event MAY reference zero or more parent trace events.
- Cycles are forbidden.

Trace DAG properties:
- Causality is explicit.
- Temporal order is NOT authoritative.
- Multiple parent links are permitted.
- Absence of a parent link implies independent origin, not simultaneity.

Trace DAG guarantees:
- Every decision-producing action MUST emit at least one trace event.
- Every trace event MUST belong to exactly one trace DAG.
- Trace DAG identity MUST be stable across export and inspection.

Naming:
- "Trace Directed Acyclic Graph" is the canonical name.
- "trace DAG" is the permitted abbreviation.

Trace DAG is authoritative for:
- causal explanation
- audit reconstruction
- debugger correlation
- policy enforcement provenance

Trace DAG is NOT authoritative for:
- state reconstruction
- replay semantics
- rollback eligibility


===============================================================================
14. WINDOWS AND SAFEPOINTWINDOWS (LOCKED)
===============================================================================

An AppInstance maintains an ordered sequence of Windows.

A Window is a bounded segment of runtime history and evidence.

A Window is exactly one of:
- SafePointWindow
- AbortedWindow
- ActiveWindow

Exactly one ActiveWindow MAY exist per AppInstance.
ActiveWindow, if it exists, MUST be the last Window in the sequence.


14.1 SafePointWindow
--------------------

A SafePointWindow is an authoritative committed boundary.

A SafePointWindow MUST satisfy:
- all state mutations included are committed
- no transactional layer state is included
- the SafePointWindow is restorable deterministically
- the SafePointWindow is trace-correlated and explainable via the trace DAG

A SafePointWindow MUST contain:
- committed layers and committed config (authoritative)
- trace DAG material sufficient to identify the SafePointWindow and its scope

A SafePointWindow MUST NOT contain:
- transactional layer contents

A SafePointWindow MAY contain (policy-driven):
- revision history
- journal material
- additional trace or journal not required for correctness

A SafePointWindow MUST have:
- safePointWindowId (stable identity)

Retention and garbage collection:
- trace, journal, and revisions within a SafePointWindow MAY be truncated or
  removed per explicit policy
- at least one authoritative value per committed key MUST remain sufficient to
  restore the SafePointWindow deterministically


14.2 ActiveWindow
-----------------

ActiveWindow is the current in-flight region after the last SafePointWindow.

ActiveWindow MUST contain:
- trace DAG events emitted after the last SafePointWindow
- journal entries produced after the last SafePointWindow
- metadata about active Orchestration Units sufficient for diagnosis
- transactional staging layers and in-flight transactional state

Rules (LOCKED):
- ActiveWindow MUST be treated as non-authoritative.
- ActiveWindow MAY be discarded during recovery.

Immutability rule (pressure handling) (LOCKED):
- ActiveWindow trace and journal MUST NOT be pruned or garbage collected.
- If storage pressure occurs:
  - journal writes MAY be dropped (as already defined) but the drop MUST be
    trace-visible and classified
  - trace events MUST still record the fact of omission


14.3 AbortedWindow
------------------

An AbortedWindow is a finalized ActiveWindow that did NOT produce committed
state changes.

An AbortedWindow MUST contain:
- trace DAG events describing what happened post-previous SafePointWindow
- a finalization event identifying the abort outcome and reason category

An AbortedWindow MAY contain:
- journal evidence (policy-driven)

An AbortedWindow MUST NOT contain:
- committed layers or config changes
- transactional layer contents
- claims of authority

An AbortedWindow MUST have:
- abortedWindowId (stable identity)

Retention and garbage collection (LOCKED):
- AbortedWindow trace and journal MAY be truncated or removed per explicit
  policy
- if an AbortedWindow is retained (not fully removed), it MUST retain enough
  trace meaning to explain:
  - that it was aborted (not committed)
  - why it was aborted (reason category and causal links)
- an AbortedWindow MAY be fully removed only if policy permits and at least
  one later SafePointWindow exists OR the engine explicitly accepts loss of
  that audit region


14.4 Finalization Rules
-----------------------

ActiveWindow MUST be finalized as exactly one of:
- SafePointWindow (commit path)
- AbortedWindow (abort or fail path)

Finalizing ActiveWindow into SafePointWindow (LOCKED):
- requires that all applicable transactions are resolved (committed or aborted)
- produces a SafePointWindow with a new safePointId
- produces a trace event SafePointCreationSucceeded

Finalizing ActiveWindow into AbortedWindow (LOCKED):
- occurs when in-flight work concludes without producing a new SafePointWindow
  and committed state remains as the last SafePointWindow
- produces a trace event ActiveWindowFinalizedAborted with reason category

Finalization MUST NOT produce partial artifacts.


14.5 Ordered List Representation
--------------------------------

The Window sequence can be represented as an ordered list.

Rules (LOCKED):
- SafePointWindow has safePointId
- AbortedWindow has abortedWindowId
- ordering is explicit (sequence index)
- ActiveWindow does not require an id because it is always last, unique, and
  mutable-in-progress


14.6 SafePointWindow Creation Request Modes
-------------------------------------------

Turnix MAY support multiple SafePointWindow creation request modes.

Mode A: ImmediateCommitted

Meaning:
- creation MUST NOT wait for quiescence
- if an eligible SafePointWindow can be created immediately, it is created
- if a SafePointWindow cannot be created immediately, the request fails
  deterministically with explicit reason

Mode B: AtQuiescence

Meaning:
- creation is attempted only when no Orchestration Unit is active for the
  target AppInstance
- the request MAY be queued until quiescence is reached

If Mode B is supported, it MUST be policy-bounded as defined below.


14.7 AtQuiescence Queueing and Policy Bounds
--------------------------------------------

If AtQuiescence is requested while an Orchestration Unit is active:
- Turnix MAY queue the request until quiescence is reached.
- Turnix MUST emit a trace event at request time indicating the request is
  queued and not yet satisfied.
- Turnix MUST emit a trace event when creation succeeds, fails, times out,
  or is cancelled.

If queued requests are not persisted, this MUST be explicit:
- a queued AtQuiescence request MAY be lost on crash or restart
- loss MUST NOT be silent and MUST be trace-visible before the crash point
  when possible

AtQuiescence requests MUST be bounded by explicit policy. Policy options:

A) Timeout
- the request MUST fail deterministically after the configured time limit
  if quiescence is not reached

B) PauseAtSafePoint
- Turnix MAY attempt a deterministic pause at a defined safe point as
  described in DA-13
- if safe-point pause cannot be achieved safely, Turnix MUST fail the request
  with an explicit reason

AtQuiescence MUST NOT:
- silently wait forever
- silently cancel in-flight work
- silently downgrade into ImmediateCommitted without explicit user or policy


14.8 Trace DAG Correlation Rules
--------------------------------

The trace DAG records decisions and causality.

SafePointWindow correlation rules (LOCKED):
- Each SafePointWindow MUST have a trace DAG event identifying it.
- The trace DAG MUST identify:
  - safePointId
  - the committed scope(s) it covers
  - the reason it was created
  - whether it includes revision or journal material per policy

The trace DAG MUST distinguish:
- events that contributed to committed state at the SafePointWindow
- events that occurred after the SafePointWindow (ActiveWindow events)

This distinction MUST NOT rely on timestamps alone.


14.9 SafePointWindow Creation Events
------------------------------------

Turnix MUST emit trace DAG events for:
- SafePointWindow creation request
- SafePointWindow creation start
- SafePointWindow creation success
- SafePointWindow creation failure
- SafePointWindow creation cancellation (policy-driven)

SafePointWindow creation failure MUST NOT create partial artifacts.
SafePointWindow creation cancellation MUST be explicit and trace-visible.


14.10 Authority and Determinism Boundary
----------------------------------------

SafePointWindow guarantees (LOCKED):
- determinism of committed state restoration
- ability to reconstruct which committed values exist and why
- committed state does not depend on journal completeness
- committed state does not depend on non-committed transactions

ActiveWindow non-guarantees (LOCKED):
- no deterministic replay of in-flight work
- no deterministic reproduction of external side effects
- no deterministic ordering after restart beyond SafePointWindow restoration

If a crash occurs within the ActiveWindow (LOCKED):
- the system MAY discard all ActiveWindow activity
- the system MAY attempt to resume, but MUST treat resumption as new work
- any such attempt MUST be explicit and trace-visible


===============================================================================
15. WINDOWMANIFESTS AND EXPORTS (OPEN WITH LOCKED CONSTRAINTS)
===============================================================================

A WindowManifest is an immutable manifest representing exactly one finalized
Window (SafePointWindow or AbortedWindow).

This section remains OPEN regarding exact serialization formats, but has
LOCKED constraints and LOCKED interoperability contracts with ChunkId and
ValueRef.


15.1 Locked WindowManifest Constraints
--------------------------------------

Rules (LOCKED):
- A WindowManifest MUST be immutable once created.
- A WindowManifest MUST represent exactly one finalized Window.
- A WindowManifest MUST NOT represent an ActiveWindow.
- A WindowManifest MUST be inspectable offline (Section 15.7).

Authority rules (LOCKED):
- A SafePointWindowManifest MAY contain authoritative committed state roots.
- An AbortedWindowManifest MUST NOT contain authoritative committed state
  roots.
- Trace, journal, and MAB roots are evidence-only and MUST be labeled as such.


15.2 WindowManifest Types
-------------------------

A WindowManifest is exactly one of:
- SafePointWindowManifest
- AbortedWindowManifest


15.3 SafePointWindowManifest
----------------------------

LOCKED WITH OPEN FORMATS.

A SafePointWindowManifest MUST include:
- safePointWindowId
- windowType = SafePointWindow
- committedStateRoot

Definition:
- committedStateRoot is a ChunkId of a manifest or index that enumerates all
  committed layers and committed config for that SafePointWindow by ValueRef.

Optional roots (policy-driven):
- traceRoot
- journalRoot
- revisionRoot
- mabRoot

Rules (LOCKED):
- Optional roots MUST NOT add authority.
- Optional roots MUST be explicitly labeled non-authoritative evidence.


15.4 AbortedWindowManifest
--------------------------

LOCKED WITH OPEN FORMATS.

An AbortedWindowManifest MUST include:
- abortedWindowId
- windowType = AbortedWindow
- traceRoot

Optional roots (policy-driven):
- journalRoot
- mabRoot

Rules (LOCKED):
- An AbortedWindowManifest MUST NOT define committedStateRoot.
- If traceRoot is absent, the AbortedWindowManifest MUST explicitly declare
  "traceAbsent" and the reason category for absence (policy, pruned, corrupt).
- A default AbortedWindowManifest SHOULD include traceRoot.


15.5 Evidence Carry-Forward Consistency
---------------------------------------

Carry-forward rule for optional evidence (LOCKED):
- If a WindowManifest includes trace evidence, it MAY reference chunks whose
  creation predates the window, but only to preserve internal consistency of
  included evidence.
- If a WindowManifest includes a trace span close event, the corresponding
  span
  open event MUST also be included.

[NOTE] The ordering rule for span open before span close is LOCKED in DA-12.


15.6 Window Exports
-------------------

LOCKED POLICY + OPEN FORMATS.

Export is a portable, immutable serialization of one WindowManifest closure.

Terminology:
- WindowExport: an exported artifact derived from a WindowManifest
- SafePointWindowExport: a WindowExport derived from SafePointWindowManifest
- AbortedWindowExport: a WindowExport derived from AbortedWindowManifest

Rules (LOCKED):
- Export MUST NOT add authority.
- Export MUST NOT include transactional layer contents.
- Export MUST be self-contained with respect to retained payloads.

Meaning:
- A WindowExport MUST copy into itself every referenced chunk required to
  decode the exported closure, subject to explicit "partial export" policy.
- If partial export is used, missing material MUST be explicit and impacts
  comparison results (NotComparable).


15.7 Offline Inspection
-----------------------

WindowManifests and WindowExports MUST be inspectable offline.

Meaning:
- An offline tool MAY resolve referenced ChunkIds and decode ValueRefs without
  running Turnix orchestration logic.

Rules (LOCKED):
- Offline inspection MUST NOT require capability calls.
- Offline inspection MUST NOT require journal completeness.
- Offline inspection MUST treat evidence roots as evidence only.


15.8 Window Digest Support
--------------------------

OPEN WITH LOCKED CONSTRAINTS.

Purpose:
- provide OPTIONAL accelerators for equality checks
- digests are not identities
- digests exist only to avoid expensive deep comparisons

Rules (LOCKED):
- A digest field MAY be present in WindowManifests or WindowExports.
- If present, a digest MUST be computed from a canonical serialization of the
  compared material for that digest type.
- If canonical serialization rules are not defined for a digest type, that
  digest type MUST NOT be emitted.
- Tools MUST treat digests as hints:
  - if digests match, tools MAY conclude Equal for the corresponding mode
  - if digests differ, tools MUST conclude NotEqual for the corresponding mode
  - if a digest is missing, tools MUST compute it on demand OR fall back to
    structural comparison

Digest fields (non-exhaustive):
- stateDigest
  Canonical serialization of committed layers and committed config only.
- strictStateDigest
  Canonical serialization of committed state plus revision material included
  per declared strict mode.
- evidenceDigest
  Canonical serialization of included trace, journal material per declared
  inclusion policy.
- exportManifestDigest
  Canonical serialization of the export manifest logical content.


15.9 Equality Modes
-------------------

Equality checks MAY be performed in multiple modes.

Definitions (LOCKED):

A) StateEquality
- compares committed key/value pairs only (latest values only)
- ignores revision history entirely

B) StrictStateEquality
- compares committed key/value pairs AND revision history that is present
- if required revision material is missing for one side, result is
  NotComparable (not NotEqual)

C) EvidenceEquality
- compares included evidence closure (trace, journal, MAB as included)
- does not imply equality of state unless used in addition to state modes

D) ExportEquality
- compares export closure as packaged, including declared partial or missing
  flags
- intended for verifying that two exports are the same packaged artifact

Rules (LOCKED):
- Tools MUST state which mode is used.
- Default mode MUST be StateEquality unless explicitly requested otherwise.


===============================================================================
16. MINIMAL AUDIT BUNDLE (MAB) (LOCKED)
===============================================================================

A Minimal Audit Bundle (MAB) is a non-authoritative export artifact intended
to support audit, explanation, and offline inspection.

Purpose:
- capture sufficient evidence to explain what happened and why
- allow external or offline audit
- preserve causal structure without requiring full state

A MAB is NOT:
- authoritative state
- a WindowManifest
- replayable
- sufficient for restoration


16.1 MAB Required Contents
--------------------------

A Minimal Audit Bundle MUST include:
- one or more trace DAGs
- all trace events referenced by those DAGs
- trace metadata required to interpret reason codes
- enough metadata to correlate trace events to:
  - AppInstance identity
  - session identity
  - Orchestration Unit identity (if applicable)
  - safePointWindowId and WindowExport identity (if any)

A Minimal Audit Bundle MUST NOT include:
- authoritative committed state in full
- transactional layers
- uncommitted mutations
- executable code
- capability implementations
- secrets or credentials


16.2 MAB Optional Contents
--------------------------

A Minimal Audit Bundle MAY include:
- selected journal entries referenced by trace events
- selected committed state excerpts (read-only)
- revision metadata without value payloads

If included, journal material:
- MUST preserve journal metadata (including retention class)
- MAY be incomplete, truncated, or redacted per explicit policy

If included, state excerpts:
- MUST be labeled non-authoritative
- MUST be read-only
- MUST include revision identifiers
- MUST NOT imply completeness


16.3 MAB Integrity and Loss Model
---------------------------------

Integrity guarantees (LOCKED):
- A MAB MUST preserve trace DAG structure exactly.
- Trace parent-child relationships MUST NOT be altered.
- Missing data MUST be explicitly marked.

Loss tolerance (LOCKED):
- A MAB MAY be incomplete.
- Incompleteness MUST be explicit.
- Absence of data MUST NOT imply absence of behavior.

MAB creation failure (LOCKED):
- MUST emit trace events
- MUST NOT affect runtime state

MAB creation (LOCKED):
- MAY occur while Turnix is running
- MUST NOT pause execution by default
- MUST NOT block orchestration


16.4 MAB Non-goals
------------------

A Minimal Audit Bundle explicitly does NOT provide:
- determinism guarantees
- replay capability
- state restoration
- debugging time travel
- completeness guarantees


===============================================================================
17. MEMORY INSPECTOR AND TOOLING SEMANTICS (LOCKED STATE CONTRACT)
===============================================================================

The Memory Inspector is a tooling surface for observing and manipulating
Turnix-managed memory.

This section defines memory and state semantics only. Breakpoint triggering,
pause behavior, and execution control are governed by DA-13.

Capabilities:
- enumerate memory layers and their composition
- inspect values with:
  - origin layer
  - revision identifiers
  - transactional visibility
- view active transactional stacks
- inspect staged vs committed values

Transactional interaction:
- Inspector-initiated edits MUST occur inside a transaction.
- The inspector MAY create its own temporary transactional overlay.
- Inspector transactions follow the same commit or abort rules as runtime
  transactions.
- Inspector commits propagate only one layer downward.
- Inspector actions MUST NOT finalize committed state mid-pipeline.

Undo / redo semantics:
- Undo operates on committed revisions.
- Redo is inspector-local, ephemeral, and non-authoritative.
- Redo history MUST be discarded deterministically when a new revision is
  committed.

Breakpoints and change observation:
- Memory breakpoints MAY observe:
  - committed layer mutations
  - transactional layer mutations
- Whether transactional changes trigger breakpoints is defined by DA-13
  breakpoint configuration and safe-point rules.

Debugger-initiated mutation:
- Obeys all ownership, permission, and scope rules.
- Is trace-labeled as tooling activity.
- May be staged and applied at safe points (DA-13).


===============================================================================
18. REPLAY, RESUME, AND RETRY (LOCKED)
===============================================================================

Replay is deterministic reconstruction of a SafePointWindow state and its
causal story.

Replay in Turnix means:
- restore committed state at a SafePointWindow
- inspect or step through trace DAG events that produced it

Replay MUST NOT:
- imply re-running external effects
- imply deterministically reproducing the ActiveWindow

Resume is the attempt to continue execution after restoring a SafePointWindow.

Resume MAY involve:
- re-running orchestration units that were in-flight
- retrying external calls
- abandoning in-flight work and starting new work

Rules (LOCKED):
- Resume is not deterministic in outcome.
- Resume MUST be explicit and trace-visible.

Retry is a new orchestration attempt for a previously failed or incomplete
action.

Examples:
- a model call
- a network call
- a file write

Rules (LOCKED):
- Retry MUST be modeled as new work.
- Retry MUST be trace-visible.
- Retry MUST NOT be implied by replay.


===============================================================================
19. MIGRATION COMMIT RULE (LOCKED)
===============================================================================

Migration mechanics are defined in DA-10 (IoManager rollback guarantees) and
in DA-14 (policy and user decision handling). This section locks the state
contract because it affects determinism boundaries.

Rules (LOCKED):
- Migration that changes authoritative committed state MUST occur as normal
  orchestrated work inside a transaction.
- A migration that changes authoritative committed state MUST result in a new
  SafePointWindow on success.
- Migration MUST be abortable. If migration aborts, partial authoritative
  mutation MUST NOT occur.

Implication (LOCKED):
- If a migration attempts multiple changes, the migration transaction MUST be
  atomic with respect to authoritative layers and committed config.
- If the migration cannot complete safely, it MUST abort, leaving
  authoritative state identical to the pre-migration SafePointWindow.


===============================================================================
20. CROSS-SESSION AUDIT WORKFLOWS (OPEN)
===============================================================================

Audit workflows operate across:
- traces
- committed state
- revisions
- journal entries

Audit MAY support:
- reconstructing decision chains
- inspecting state evolution over time
- correlating journal evidence with trace events

Audit workflows MUST NOT:
- mutate state
- require journal completeness
- assume replayability


===============================================================================
21. WHAT IS EXPLICITLY NOT REQUIRED
===============================================================================

Turnix does NOT require:
- infinite history
- journal-backed replay
- journal-backed determinism
- journal-backed recovery
- concurrency-first execution
- audit completeness guarantees


===============================================================================
22. COMPARISON RESULT TYPE (LOCKED)
===============================================================================

All equality checks MUST return a ComparisonResult.

ComparisonResult is an enum with exactly three values:
- Equal
- NotEqual
- NotComparable

Rules (LOCKED):
- ComparisonResult MUST NOT be represented as:
  - boolean
  - integer
  - float
  - string not in the enum set
- APIs MUST NOT provide alternate return types or "truthy/falsy" equivalents.
- If an API language lacks enums, the API MUST expose:
  - a closed set of named constants, OR
  - a tagged union or sealed type
  with exactly the three values above.
- Any comparison API that offers a convenience boolean (example: isEqual())
  MUST be forbidden.

Behavior rules (LOCKED):
- NotComparable MUST be returned when required material is missing due to:
  - policy pruning
  - partial export
  - corruption
  - unsupported strict submode
- NotComparable MUST NOT be treated as NotEqual by Turnix tooling.
- Any user interface presentation MUST distinguish NotComparable from
  NotEqual.


===============================================================================
23. LOCKED SUMMARY
===============================================================================

LOCKED:
- Memory vs State authority boundary (only committed state is authoritative)
- storage-neutral payload model:
  - committed keys representable as (key -> ValueRef)
  - Chunk identity and integrity rules
  - IoManager mediation for ValueRef or Chunk persistence
  - schemaless default with optional schema fields
  - payload sharing across artifacts without changing authority
- layered memory model
- transactional staging with atomic commit or abort
- nested transaction stacking for child pipeline runs
- commit conflict detection for commits into committed layers
- single-lane AppInstance orchestration with orchestration re-entry boundaries
- persistence as protection, not truth
- static data Patch or Copy mutation intent
- revisions retention and reachability-safe garbage collection
- journal as best-effort non-authoritative evidence
- trace DAG as causal authority (not state authority)
- window model with SafePointWindow, ActiveWindow, AbortedWindow
- SafePointWindow determinism boundary and ActiveWindow non-guarantees
- WindowManifest model:
  - SafePointWindowManifest has committedStateRoot
  - AbortedWindowManifest has evidence roots only
  - manifests are immutable and offline inspectable
- WindowExport model:
  - portable, immutable closure of a WindowManifest
  - exports are self-contained unless explicitly partial
- Minimal Audit Bundle non-authoritative semantics and integrity rules
- Memory Inspector edits via transactions and trace-labeled tooling mutation
- Replay, Resume, Retry definitions and non-guarantees
- migration commit rule requiring atomic transaction and new SafePointWindow
- digest support for manifests and exports:
  - digests are optional and computed on demand
  - digests are derived from canonical serialization rules
  - missing digests require computation or structural comparison
- equality modes and ComparisonResult enum requirements

OPEN:
- ChunkId encoding choice beyond LOCKED constraints
- WindowManifest and WindowExport serialization formats beyond LOCKED
  constraints
- optional chunk features beyond LOCKED constraints (compression, encryption,
  streaming, packing, paging, index chunks)
- digest algorithms and canonical serialization choices for each digest type
- cross-session audit workflows and tooling user experience


===============================================================================
END OF DESIGN AREA 15
===============================================================================


--- doc-meta ---
docId: docs/design/DA-15_MEMORY_STATE_LAYERS_AND_JOURNALING.txt
rev: 1
git: 0000000
----------------
